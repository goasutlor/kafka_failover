<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kafka Multi-Region Failover Simulation (Custom Builder)</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Prefer Google Sans Text if available; fall back to Plus Jakarta Sans/Inter */
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Google Sans Text', 'Plus Jakarta Sans', 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Liberation Sans', sans-serif;
            background-color: #f6f7fb; /* soft light */
            min-height: 100vh;
            margin: 0;
            padding: 0;
            color: #111827; /* gray-900 */
        }
        .card {
            background: #ffffff;
            box-shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
            transition: box-shadow 0.25s ease, transform 0.25s ease;
            border-radius: 16px;
            border: 1px solid #e5e7eb; /* gray-200 */
        }
        .card:hover {
            transform: translateY(-1px);
            box-shadow: 0 16px 32px rgba(15, 23, 42, 0.12);
        }
        
        /* Custom animations for leader changes */
        @keyframes leaderChange {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7); }
            50% { transform: scale(1.02); box-shadow: 0 0 0 10px rgba(245, 158, 11, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245, 158, 11, 0); }
        }
        
        @keyframes leaderPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .leader-change-animation {
            animation: leaderChange 2s ease-in-out;
        }
        
        .leader-pulse-animation {
            animation: leaderPulse 1.5s ease-in-out infinite;
        }
        
        .change-indicator {
            position: relative;
        }
        
        .change-indicator::before {
            content: "🔄";
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 12px;
            animation: leaderPulse 1s ease-in-out infinite;
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        /* Status Colors - minimal */
        .up { background-color: #10b981; }
        .down { background-color: #ef4444; }
        .partial { background-color: #f59e0b; }
        .unavailable { background-color: #9ca3af; }
        .quorum-maintained { color: #065f46; font-weight: 600; }
        .quorum-lost { color: #b91c1c; font-weight: 600; }

        /* Custom Clickable Box Styling - Minimal */
        .status-box-toggle {
            cursor: pointer;
            padding: 8px 10px;
            border-radius: 10px;
            text-align: center;
            font-size: 10px;
            font-weight: 600;
            transition: box-shadow 0.2s ease, transform 0.2s ease, background-color 0.2s ease;
            border: 1px solid #e5e7eb;
            min-width: 70px;
            box-shadow: 0 4px 12px rgba(15, 23, 42, 0.06);
        }
        .status-box-toggle.up-state {
            background: #ecfdf5;
            color: #065f46;
            border-color: #d1fae5;
        }
        .status-box-toggle.down-state {
            background: #fef2f2;
            color: #7f1d1d;
            border-color: #fee2e2;
        }

        /* Fixed height for the log container with scroll - Minimal */
        #sequence_log_container {
            max-height: 320px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            background: #f9fafb;
        }
        /* Fixed height for partition status container */
        #partition_status {
            min-height: 140px;
        }
        .input-group {
            border: 1px solid #e5e7eb;
            background: #ffffff;
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.06);
        }
        /* New Grouping Styles - Minimal */
        .component-group-container {
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            background: #ffffff;
            padding: 1.25rem;
            height: 100%;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.06);
            transition: box-shadow 0.25s ease, transform 0.25s ease;
        }
        .component-group-container:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 28px rgba(15, 23, 42, 0.10);
        }
        /* Tighter grid for controls */
        .control-grid-1 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: 8px;
        }
        .control-grid-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 8px;
        }
        /* Minimal Buttons */
        .btn {
            background-color: #1f2937; /* gray-800 */
            color: #ffffff;
            border: 1px solid #1f2937;
            border-radius: 10px;
            padding: 10px 16px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
            box-shadow: 0 6px 20px rgba(17, 24, 39, 0.12);
        }
        .btn:hover { background-color: #111827; transform: translateY(-1px); }
        .btn-danger { background-color: #dc2626; border-color: #dc2626; }
        .btn-danger:hover { background-color: #b91c1c; }
        .btn-success { background-color: #2563eb; border-color: #2563eb; }
        .btn-success:hover { background-color: #1d4ed8; }
    </style>
</head>
<body class="p-4 sm:p-6 lg:p-10">

    <div class="max-w-full mx-auto rounded-3xl card p-8 sm:p-10 lg:p-12">
        <h1 class="text-3xl font-extrabold text-gray-900 mb-2 text-center tracking-tight">Confluent Kafka Multi-Region Failover Simulation</h1>
        <p class="text-gray-500 mb-8 text-center text-sm leading-6">Architecture: Confluent Kafka Single Cluster on 2 separate OCP Sites (DC1/DC2) with External KRaft Quorum Controller (Site 3)</p>

        <!-- MAIN TWO-COLUMN CONTAINER -->
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8 lg:gap-10">

            <!-- LEFT COLUMN: CONTROLS & STATUS (COL-SPAN-5) -->
            <div class="lg:col-span-5 space-y-6">
                
                <!-- LAYER 1: STATUS OVERVIEW (Horizontal Cards) -->
                <div class="space-y-6">
                    <h2 class="text-xl font-bold text-gray-900 mb-2">Confluent Cluster Status Overview</h2>
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                        
                        <!-- DC1 Panel -->
                        <div id="dc1_panel" class="p-6 rounded-2xl card border-t-4 border-blue-600">
                            <h3 class="text-base font-bold text-blue-700 mb-2">DC1 Status</h3>
                            <div id="dc1_components_status" class="space-y-2 text-sm">
                                <p class="text-gray-800 font-medium">Broker: <span id="dc1_broker_status" class="up text-green-600 font-extrabold">UP</span></p>
                                <p class="text-gray-800 font-medium">KRaft Ctrls: <span id="dc1_kraft_status" class="up text-green-600 font-extrabold">UP</span></p>
                                <p class="text-gray-800 font-medium">Connect/SR: <span id="dc1_service_status" class="up text-green-600 font-extrabold">UP</span></p>
                            </div>
                            <p class="mt-3 text-xs font-semibold text-blue-800 border-t pt-2">Ingress VIP: <span id="dc1_ingress_status_text">UP</span></p>
                        </div>
                        
                        <!-- Site 3: Quorum Controller -->
                        <div id="site3_panel" class="p-6 rounded-2xl card border-t-4 border-gray-500">
                            <h3 class="text-base font-bold text-gray-700 mb-2">Site 3 Quorum</h3>
                            <div class="flex items-center space-x-3 text-sm mt-2">
                                <span id="quorum_status_dot" class="status-dot up"></span>
                                <span id="quorum_status_text" class="font-bold text-gray-800">C5 | UP</span>
                            </div>
                            <p class="mt-3 text-xs text-gray-600 border-t pt-2">Quorum: <span id="quorum_consensus" class="quorum-maintained text-base">MAINTAINED</span></p>
                        </div>

                        <!-- DC2 Panel -->
                        <div id="dc2_panel" class="p-6 rounded-2xl card border-t-4 border-green-600">
                            <h3 class="text-base font-bold text-green-700 mb-2">DC2 Status</h3>
                            <div id="dc2_components_status" class="space-y-2 text-sm">
                                <p class="text-gray-800 font-medium">Broker: <span id="dc2_broker_status" class="up text-green-600 font-extrabold">UP</span></p>
                                <p class="text-gray-800 font-medium">KRaft Ctrls: <span id="dc2_kraft_status" class="up text-green-600 font-extrabold">UP</span></p>
                                <p class="text-gray-800 font-medium">Connect/SR: <span id="dc2_service_status" class="up text-green-600 font-extrabold">UP</span></p>
                            </div>
                            <p class="mt-3 text-xs font-semibold text-green-800 border-t pt-2">Ingress VIP: <span id="dc2_ingress_status_text">UP</span></p>
                        </div>
                    </div>
                </div>


                <!-- LAYER 2: CUSTOM SCENARIO BUILDER (Site-centric Layout) -->
                <div class="bg-white rounded-2xl border border-gray-200 space-y-4 shadow-sm p-6">
                    <h2 class="text-xl font-bold text-gray-900">Custom Scenario Builder</h2>
                    <p class="text-sm text-gray-600">Click components to toggle status (UP / DOWN) and define failure scenario.</p>
                    
                    <!-- Architecture Note: VIP Down = Site Down -->
                    <div class="bg-indigo-50 border-l-4 border-indigo-500 p-4 rounded">
                        <div class="flex items-start">
                            <div class="flex-shrink-0">
                                <svg class="h-5 w-5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                                </svg>
                            </div>
                            <div class="ml-3">
                                <h3 class="text-sm font-bold text-indigo-800">Architecture Note: Centralized Gateway Model</h3>
                                <div class="mt-2 text-xs text-indigo-700">
                                    <p class="mb-1"><strong>In this deployment architecture:</strong></p>
                                    <ul class="list-disc list-inside space-y-1">
                                        <li><strong>All communication</strong> (internal pod-to-pod and external client-to-broker) routes through <strong>Egress → F5 VIP Ingress</strong></li>
                                        <li><strong>VIP Down = Complete Site Failure</strong> - All services in that site become unreachable, even for internal communication</li>
                                        <li>Controllers in a down-VIP site <strong>cannot participate in quorum</strong> (no network path)</li>
                                        <li>Brokers in a down-VIP site <strong>cannot serve data or sync replicas</strong></li>
                                    </ul>
                                    <p class="mt-2 text-indigo-600 italic">💡 This differs from direct pod-to-pod architectures where internal communication may survive VIP failures.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- New 3-Column Site-Centric Control Grid -->
                    <div id="control_groups" class="grid grid-cols-3 gap-4">
                        
                        <!-- DC1 Controls -->
                        <div id="dc1_controls" class="component-group-container border-t-4 border-blue-600 space-y-3">
                            <h3 class="font-extrabold text-sm text-blue-700 border-b pb-1">DC1 Components</h3>
                            
                            <!-- DC1 Ingress (Gateway) -->
                            <div class="space-y-1">
                                <p class="text-[10px] font-bold text-blue-700">Gateway (Ingress VIP)</p>
                                <div id="dc1_ingress_top" class="control-grid-1"></div>
                            </div>

                            <!-- DC1 Controllers -->
                            <div class="space-y-1">
                                <p class="text-[10px] font-bold text-gray-600">KRaft Ctrls (C1, C2)</p>
                                <div id="dc1_controllers_container" class="control-grid-1"></div>
                            </div>
                            
                            <!-- DC1 Brokers -->
                            <div class="space-y-1">
                                <p class="text-[10px] font-bold text-gray-600">Kafka Brokers (A1, A2, A3)</p>
                                <div id="dc1_brokers_container" class="control-grid-1"></div>
                            </div>

                            <!-- DC1 Services -->
                            <div class="space-y-1">
                                <p class="text-[10px] font-bold text-gray-600">Services</p>
                                <div id="dc1_services_container" class="control-grid-1"></div>
                            </div>
                            <!-- New Button for DC1 All Down -->
                            <button onclick="toggleSiteStatus('DC1', 'DOWN')" class="btn btn-danger w-full mt-2">
                                DC1 Down All
                            </button>
                        </div>

                        <!-- Site 3 Controls -->
                        <div id="site3_controls" class="component-group-container border-t-4 border-gray-500 space-y-3">
                            <h3 class="font-extrabold text-sm text-gray-700 border-b pb-1">Site 3 Components</h3>
                            
                            <!-- Site 3 Controllers -->
                            <div class="space-y-1">
                                <p class="text-[10px] font-bold text-gray-600">KRaft Controller (C5)</p>
                                <div id="site3_controllers_container" class="control-grid-1"></div>
                            </div>
                        </div>

                        <!-- DC2 Controls -->
                        <div id="dc2_controls" class="component-group-container border-t-4 border-green-600 space-y-3">
                            <h3 class="font-extrabold text-sm text-green-700 border-b pb-1">DC2 Components</h3>

                            <!-- DC2 Ingress (Gateway) -->
                            <div class="space-y-1">
                                <p class="text-[10px] font-bold text-green-700">Gateway (Ingress VIP)</p>
                                <div id="dc2_ingress_top" class="control-grid-1"></div>
                            </div>

                            <!-- DC2 Controllers -->
                            <div class="space-y-1">
                                <p class="text-[10px] font-bold text-gray-600">KRaft Ctrls (C3, C4)</p>
                                <div id="dc2_controllers_container" class="control-grid-1"></div>
                            </div>
                            
                            <!-- DC2 Brokers -->
                            <div class="space-y-1">
                                <p class="text-[10px] font-bold text-gray-600">Kafka Brokers (B1, B2, B3)</p>
                                <div id="dc2_brokers_container" class="control-grid-1"></div>
                            </div>

                            <!-- DC2 Services -->
                            <div class="space-y-1">
                                <p class="text-[10px] font-bold text-gray-600">Services</p>
                                <div id="dc2_services_container" class="control-grid-1"></div>
                            </div>
                            <!-- New Button for DC2 All Down -->
                            <button onclick="toggleSiteStatus('DC2', 'DOWN')" class="btn btn-danger w-full mt-2">
                                DC2 Down All
                            </button>
                        </div>
                    </div>
                    
                    <button onclick="runScenario(5)" class="btn btn-success w-full mt-4">
                        Restore All UP
                    </button>
                </div>
            </div>

            <!-- RIGHT COLUMN: RESULTS & LOG (COL-SPAN-7) -->
            <div class="lg:col-span-7 space-y-6 pt-4 lg:pt-0">
                <!-- Configuration Controls and Impact - 2 Column Layout at Top -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <!-- Left Column: Adaptive Partition Configuration -->
                    <div class="lg:col-span-1">
                        <h3 class="text-lg font-semibold text-gray-700 mb-3">Adaptive Partition Configuration</h3>
                        
                        <!-- RF Control -->
                        <div class="mb-4">
                            <label class="block text-sm font-medium text-gray-700 mb-2">Replication Factor (RF)</label>
                            <select id="rf_selector" onchange="updateRF()" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                <option value="1">RF = 1 (No Replication)</option>
                                <option value="2">RF = 2 (Basic)</option>
                                <option value="3">RF = 3 (Minimal)</option>
                                <option value="4">RF = 4 (Standard)</option>
                                <option value="5">RF = 5 (High)</option>
                                <option value="6" selected>RF = 6 (Maximum)</option>
                            </select>
                            <div id="rf_impact" class="text-sm text-gray-600 mt-1"></div>
                        </div>

                         <!-- Min ISR Control -->
                         <div class="mb-4">
                             <label class="block text-sm font-medium text-gray-700 mb-2">Min.ISR (Minimum In-Sync Replicas)</label>
                             <select id="min_isr_selector" onchange="updateMinISR()" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                 <option value="1">Min.ISR = 1 (Risky)</option>
                                 <option value="2">Min.ISR = 2 (Basic)</option>
                                 <option value="3" selected>Min.ISR = 3 (Balanced)</option>
                                 <option value="4">Min.ISR = 4 (Safe)</option>
                                 <option value="5">Min.ISR = 5 (Very Safe)</option>
                                 <option value="6">Min.ISR = 6 (Maximum)</option>
                             </select>
                             <div id="min_isr_impact" class="text-sm text-gray-600 mt-1"></div>
                        </div>

                         <!-- AOP Control -->
                         <div class="mb-4">
                             <label class="block text-sm font-medium text-gray-700 mb-2">AOP (Available Out of Partition)</label>
                             <select id="aop_selector" onchange="updateAOP()" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                 <option value="0" selected>AOP = 0 (Disabled)</option>
                                 <option value="1">AOP = 1 (1 async replica)</option>
                                 <option value="2">AOP = 2 (2 async replicas)</option>
                                 <option value="3">AOP = 3 (3 async replicas)</option>
                                 <option value="4">AOP = 4 (4 async replicas)</option>
                                 <option value="5">AOP = 5 (5 async replicas)</option>
                             </select>
                             <div id="aop_impact" class="text-sm text-gray-600 mt-1"></div>
                        </div>

                        <!-- Rack Awareness Toggle -->
                        <div class="mb-4">
                            <label class="block text-sm font-medium text-gray-700 mb-2">Rack Awareness</label>
                            <div class="flex items-center space-x-3">
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="rack_awareness_toggle" class="sr-only peer" onchange="toggleRackAwareness()">
                                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                                    <span class="ml-3 text-sm font-medium text-gray-700">Enable Rack Awareness</span>
                                </label>
                            </div>
                            <div id="rack_awareness_impact" class="text-sm text-gray-600 mt-1">🔄 Random replica distribution across all brokers</div>
                        </div>
                    </div>

                    <!-- Right Column: Configuration Impact -->
                    <div class="lg:col-span-1">
                        <h3 class="text-lg font-semibold text-gray-700 mb-3">Configuration Impact</h3>
                        <div id="config_impact" class="bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm">
                            <div class="grid grid-cols-2 gap-4 mb-3">
                                <div>
                                    <span class="font-medium text-blue-800">Disk Usage:</span>
                                    <span id="disk_usage" class="text-blue-600">6x (All Brokers)</span>
                                </div>
                                <div>
                                    <span class="font-medium text-blue-800">Tolerable Failures:</span>
                                    <span id="tolerable_failures" class="text-blue-600">3 brokers</span>
                                </div>
                </div>
                            
                            <!-- Performance Metrics -->
                            <div class="grid grid-cols-2 gap-4 mb-3 pt-2 border-t border-blue-200">
                                <div>
                                    <span class="font-medium text-blue-800">Network Traffic:</span>
                                    <span id="network_traffic" class="text-blue-600">High</span>
                                </div>
                                <div>
                                    <span class="font-medium text-blue-800">Storage Cost:</span>
                                    <span id="storage_cost" class="text-blue-600">6x Base</span>
                                </div>
                            </div>
                            
                            <!-- Risk Assessment -->
                            <div class="pt-2 border-t border-blue-200">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="font-medium text-blue-800">Risk Level:</span>
                                    <span id="risk_level" class="px-2 py-1 rounded-full text-xs font-bold bg-green-100 text-green-800">Low</span>
                                </div>
                                <div class="flex items-center justify-between">
                                    <span class="font-medium text-blue-800">Availability:</span>
                                    <span id="availability_score" class="text-blue-600 font-bold" title="Calculated based on partition availability ratio, assuming equal traffic distribution across partitions">99.99%</span>
                                </div>
                                <div class="text-xs text-gray-500 mt-1 italic">
                                    💡 Based on partition ratio (assumes equal traffic)
                                </div>
                            </div>
                            
                            <p id="config_description" class="text-blue-700 mt-3 text-xs">
                                Availability requires: ISR count ≥ Min.ISR. With RF = 6 and Min.ISR = 3, the system can tolerate up to 3 broker failures without data loss.
                            </p>
                            
                            <!-- Simulator Limitations Note -->
                            <div class="mt-4 p-3 bg-amber-50 border-l-4 border-amber-400 rounded">
                                <h4 class="text-xs font-bold text-amber-800 mb-1">⚠️ Simulator Limitations</h4>
                                <div class="text-[10px] text-amber-700 space-y-1">
                                    <p><strong>Replica Reassignment:</strong> Not simulated. In production, when brokers fail, Kafka takes <strong>minutes to hours</strong> to reassign replicas to healthy brokers (depending on data size).</p>
                                    <p><strong>Impact:</strong> This simulator shows <em>immediate state</em> after failure. In production, you must manually trigger reassignment or wait for auto-rebalancer.</p>
                                    <p class="italic">💡 Use Confluent Control Center or kafka-reassign-partitions tool in production.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Results and Failover Flow (Full Width Below Configuration) -->
                <h2 class="text-xl font-bold text-gray-900 mb-2">Results and Failover Flow</h2>


                <!-- Control Plane Status -->
                <div class="mb-4">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Control Plane Status</h3>
                    <div id="control_plane_status" class="p-4 rounded-lg border">
                        <!-- Rendered by JS -->
                    </div>
                </div>

                <!-- Partition Status -->
                <div class="mb-4">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Partition Data Availability</h3>
                    <div id="partition_status" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <!-- Rendered by JS -->
                    </div>
                </div>

                <!-- Client & Service Impact -->
                <div class="mb-4 pt-3 border-t border-gray-100">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Client & Service Impact</h3>
                    <div id="client_impact" class="space-y-3 text-sm text-gray-800">
                        <p id="producer_impact"></p>
                        <p id="consumer_impact"></p>
                        <p id="service_impact"></p>
                    </div>
                </div>
                
                <!-- Failover Sequence Log (Fixed Height) -->
                <div>
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Failover Sequence Log</h3>
                    <div id="sequence_log_container" class="p-3">
                        <ol id="sequence_log" class="list-decimal list-inside space-y-1 text-xs text-gray-700">
                            <li class="text-gray-500">Use the Custom Scenario Builder above to start a simulation.</li>
                        </ol>
                    </div>
                </div>

            </div>
        </div>

    </div>

    <script>
        // Global variables for Firebase context (required by instructions, though not used for this local simulation)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- Configuration Constants (Now Dynamic) ---
        let MIN_ISR = 3;
        const UNCLEAN_ENABLED = false; // Safe/Disabled by default
        let RF_VALUE = 6;
        let AOP_VALUE = 0; // Available Out of Partition (default: 0 = disabled)
        let RACK_AWARENESS_ENABLED = false; // Rack Awareness toggle


        // --- Data Model & Initial State (Dynamic RF Support) ---
        let clusterState = {
            // KRaft Controllers (5 nodes total, Quorum required: 3)
            kraft_controllers: {
                C1: { site: 'DC1', status: 'UP', desc: 'Controller C1 (DC1)' }, 
                C2: { site: 'DC1', status: 'UP', desc: 'Controller C2 (DC1)' },
                C3: { site: 'DC2', status: 'UP', desc: 'Controller C3 (DC2)' },
                C4: { site: 'DC2', status: 'UP', desc: 'Controller C4 (DC2)' },
                C5: { site: 'Site3', status: 'UP', desc: 'Controller C5 (Site 3 VM)' }, // External VM
            },
            // Brokers (A1, A2, A3 in DC1; B1, B2, B3 in DC2)
            brokers: {
                A1: { site: 'DC1', status: 'UP', desc: 'Broker A1' }, 
                A2: { site: 'DC1', status: 'UP', desc: 'Broker A2' },
                A3: { site: 'DC1', status: 'UP', desc: 'Broker A3' },
                B1: { site: 'DC2', status: 'UP', desc: 'Broker B1' },
                B2: { site: 'DC2', status: 'UP', desc: 'Broker B2' },
                B3: { site: 'DC2', status: 'UP', desc: 'Broker B3' },
            },
            services: {
                DC1_CONNECT: { site: 'DC1', status: 'UP', desc: 'Connect' },
                DC1_SR: { site: 'DC1', status: 'UP', desc: 'Schema Reg' },
                DC1_INGRESS: { site: 'DC1', status: 'UP', desc: 'F5 VIP/Ingress' }, // New Ingress
                
                DC2_CONNECT: { site: 'DC2', status: 'UP', desc: 'Connect' },
                DC2_SR: { site: 'DC2', status: 'UP', desc: 'Schema Reg' },
                DC2_INGRESS: { site: 'DC2', status: 'UP', desc: 'F5 VIP/Ingress' }, // New Ingress
            },
            // Topic: SalesData (3 Partitions, Dynamic Replication Factor)
            partitions: {
                P0: { leader: 'A1', followers: ['A2', 'A3', 'B1', 'B2', 'B3'], uleUsed: false }, // Will be updated dynamically
                P1: { leader: 'B1', followers: ['B2', 'B3', 'A1', 'A2', 'A3'], uleUsed: false }, // Will be updated dynamically
                P2: { leader: 'A2', followers: ['A1', 'A3', 'B1', 'B2', 'B3'], uleUsed: false }, // Will be updated dynamically
            },
            // Configuration Parameters (Dynamic)
            config: {
                RF: RF_VALUE, 
                minISR: MIN_ISR,
                AOP: AOP_VALUE
            }
        };

        const QUORUM_SIZE = 5;
        const QUORUM_REQUIRED = 3;

        // Deep copy of the initial state for clean resets
        const initialState = JSON.parse(JSON.stringify(clusterState));

        // --- Dynamic Configuration Functions ---

        /**
         * Updates RF value and recalculates partition assignments
         */
        window.updateRF = function() {
            const rfSelect = document.getElementById('rf_selector');
            RF_VALUE = parseInt(rfSelect.value);
            
            // Update cluster state config
            clusterState.config.RF = RF_VALUE;
            
            // Recalculate partition assignments
            recalculatePartitionAssignments();
            
            // Update UI displays
            updateConfigImpact();
            
            // Update AOP selector options
            updateAOPOptions();
            
            // Update Min ISR selector options
            const minIsrSelector = document.getElementById('min_isr_selector');
            minIsrSelector.innerHTML = '';
            
            for (let i = 1; i <= RF_VALUE; i++) {
                const option = document.createElement('option');
                option.value = i;
                let label = `Min.ISR = ${i}`;
                if (i === 1) label += ' (Risky)';
                else if (i === 2) label += ' (Basic)';
                else if (i === 3) label += ' (Balanced)';
                else if (i === 4) label += ' (Safe)';
                else if (i === 5) label += ' (Very Safe)';
                else if (i === 6) label += ' (Maximum)';
                
                option.textContent = label;
                if (i === MIN_ISR) option.selected = true;
                minIsrSelector.appendChild(option);
            }
            
            // Ensure Min ISR doesn't exceed RF
            if (MIN_ISR > RF_VALUE) {
                MIN_ISR = RF_VALUE;
                minIsrSelector.value = RF_VALUE;
            }
            
            // Validate Min.ISR configuration after RF change
            validateMinISRConfiguration();
            validateAOPConfiguration();
            
            // Re-run simulation if needed
            if (typeof runSimulation === 'function') {
                setTimeout(() => {
                    runSimulation();
                    setTimeout(renderClientImpact, 100);
                }, 0);
            }
        }

        /**
         * Toggles Rack Awareness setting
         */
        window.toggleRackAwareness = function() {
            const toggle = document.getElementById('rack_awareness_toggle');
            RACK_AWARENESS_ENABLED = toggle.checked;
            
            // Update impact display
            updateRackAwarenessImpact();
            
            // Recalculate partition assignments with new rack awareness setting
            recalculatePartitionAssignments();
            
            // Re-run simulation if needed
            if (typeof runSimulation === 'function') {
                setTimeout(() => {
                    runSimulation();
                    setTimeout(renderClientImpact, 100);
                }, 0);
            }
        }

        /**
         * Updates Rack Awareness impact display
         */
        function updateRackAwarenessImpact() {
            const impactElement = document.getElementById('rack_awareness_impact');
            if (RACK_AWARENESS_ENABLED) {
                impactElement.innerHTML = `
                    <div class="text-sm text-blue-600 mt-1">
                        🏢 <strong>Balanced replica distribution</strong> across DC1/DC2 sites<br>
                        <span class="text-xs text-gray-600">
                            • Alternating pattern per partition (P0: DC1=${Math.ceil(RF_VALUE/2)}/DC2=${Math.floor(RF_VALUE/2)}, P1: DC1=${Math.floor(RF_VALUE/2)}/DC2=${Math.ceil(RF_VALUE/2)})<br>
                            • Ensures equal risk distribution across both datacenters
                        </span>
                    </div>
                `;
                impactElement.className = 'text-sm mt-1';
            } else {
                impactElement.innerHTML = '🔄 Random replica distribution across all brokers';
                impactElement.className = 'text-sm text-gray-600 mt-1';
            }
        }

        /**
         * Updates AOP selector options based on current RF
         */
        function updateAOPOptions() {
            const aopSelector = document.getElementById('aop_selector');
            if (!aopSelector) return;
            
            const maxAOP = 6 - RF_VALUE; // Guardrail: RF + AOP <= 6
            
            aopSelector.innerHTML = '';
            
            // Always include option 0 (disabled)
            const option0 = document.createElement('option');
            option0.value = '0';
            option0.textContent = 'AOP = 0 (Disabled)';
            if (AOP_VALUE === 0) option0.selected = true;
            aopSelector.appendChild(option0);
            
            // Add AOP options based on available brokers
            for (let i = 1; i <= maxAOP; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `AOP = ${i} (${i} async replica${i > 1 ? 's' : ''})`;
                if (i === AOP_VALUE) option.selected = true;
                aopSelector.appendChild(option);
            }
            
            // If current AOP exceeds max, reset to 0
            if (AOP_VALUE > maxAOP) {
                AOP_VALUE = 0;
                clusterState.config.AOP = AOP_VALUE;
                aopSelector.value = '0';
            }
        }

        /**
         * Validates AOP configuration and shows warnings
         */
        function validateAOPConfiguration() {
            const aopImpact = document.getElementById('aop_impact');
            if (!aopImpact) return;
            
            if (AOP_VALUE === 0) {
                aopImpact.innerHTML = `
                    <div class="text-sm text-blue-600 mt-1">
                        🔧 <strong>Traditional Kafka:</strong> All replicas replicate synchronously<br>
                        <span class="text-xs text-gray-600">
                            • Write operations wait for all replicas to confirm<br>
                            • Maximum data safety but slower write performance
                        </span>
                    </div>
                `;
                aopImpact.className = 'text-sm mt-1';
            } else {
                const totalReplicas = RF_VALUE + AOP_VALUE;
                const syncReplicas = RF_VALUE;
                const asyncReplicas = AOP_VALUE;
                
                aopImpact.innerHTML = `
                    <div class="text-sm text-green-600 mt-1">
                        ⚡ <strong>AOP Enabled:</strong> ${syncReplicas} sync + ${asyncReplicas} async replicas (Total: ${totalReplicas})<br>
                        <span class="text-xs text-gray-600">
                            • Write operations wait for ${syncReplicas} replicas only<br>
                            • ${asyncReplicas} replicas replicate asynchronously<br>
                            • Better write performance with maintained durability
                        </span>
                    </div>
                `;
                aopImpact.className = 'text-sm mt-1';
            }
        }

        /**
         * Updates AOP value
         */
        window.updateAOP = function() {
            const aopSelector = document.getElementById('aop_selector');
            const newAOP = parseInt(aopSelector.value);
            
            // Guardrail: RF + AOP <= Total Brokers (6)
            if (RF_VALUE + newAOP > 6) {
                alert(`Invalid AOP configuration!\nRF (${RF_VALUE}) + AOP (${newAOP}) = ${RF_VALUE + newAOP} > Total Brokers (6)\nMaximum allowed AOP = ${6 - RF_VALUE}`);
                aopSelector.value = AOP_VALUE; // Reset to previous value
                return;
            }
            
            AOP_VALUE = newAOP;
            
            // Update cluster state config
            clusterState.config.AOP = AOP_VALUE;
            
            // Update UI displays
            updateConfigImpact();
            updateAOPOptions();
            validateAOPConfiguration();
            
            // Recalculate partition assignments
            recalculatePartitionAssignments();
            
            // Force render client impact after config update
            setTimeout(() => {
                renderControlPlaneStatus();
                renderClientImpact();
                renderPartitionStatus();
            }, 50);
        }

        /**
         * Updates Min ISR value
         */
        window.updateMinISR = function() {
            const minIsrSelector = document.getElementById('min_isr_selector');
            MIN_ISR = parseInt(minIsrSelector.value);
            
            // Update cluster state config
            clusterState.config.minISR = MIN_ISR;
            
            // Validate Min.ISR and show warnings
            validateMinISRConfiguration();
            
            // Update impact display
            updateConfigImpact();
            
            // Re-run simulation if needed
            if (typeof runSimulation === 'function') {
                setTimeout(() => {
                    runSimulation();
                    setTimeout(renderClientImpact, 100);
                }, 0);
            }
        }
        
        /**
         * Validates Min.ISR configuration and displays warnings for anti-patterns
         */
        function validateMinISRConfiguration() {
            const minIsrImpact = document.getElementById('min_isr_impact');
            if (!minIsrImpact) return;
            
            // Critical Anti-Pattern: Min.ISR = RF
            if (MIN_ISR === RF_VALUE) {
                minIsrImpact.innerHTML = `
                    <div class="mt-2 p-3 bg-red-50 border-l-4 border-red-500 rounded">
                        <div class="flex items-start">
                            <span class="text-red-600 font-bold mr-2">⚠️ ANTI-PATTERN WARNING:</span>
                        </div>
                        <div class="text-xs text-red-700 mt-1">
                            <strong>Min.ISR = RF is NOT recommended for production!</strong><br>
                            • If ANY single replica falls out of sync → partition immediately goes OFFLINE<br>
                            • Zero fault tolerance - extremely fragile configuration<br>
                            • <strong>Best Practice:</strong> Min.ISR ≤ (RF/2 + 1) for RF=${RF_VALUE} → Min.ISR = ${Math.ceil(RF_VALUE/2 + 1)} recommended
                        </div>
                    </div>
                `;
                minIsrImpact.className = 'text-sm mt-1';
            } 
            // Warning: Min.ISR too high (> 80% of RF)
            else if (MIN_ISR > RF_VALUE * 0.8) {
                minIsrImpact.innerHTML = `
                    <div class="mt-2 p-3 bg-orange-50 border-l-4 border-orange-400 rounded">
                        <div class="flex items-start">
                            <span class="text-orange-600 font-bold mr-2">⚠️ CAUTION:</span>
                        </div>
                        <div class="text-xs text-orange-700 mt-1">
                            <strong>Min.ISR is very high (${MIN_ISR}/${RF_VALUE} = ${Math.round(MIN_ISR/RF_VALUE*100)}%)</strong><br>
                            • Low tolerance for replica lag → higher risk of partition unavailability<br>
                            • Consider: Min.ISR = ${Math.ceil(RF_VALUE/2 + 1)} for better balance between safety and availability
                        </div>
                    </div>
                `;
                minIsrImpact.className = 'text-sm mt-1';
            }
            // Good configuration
            else {
                minIsrImpact.innerHTML = '';
            }
        }

        /**
         * Recalculates partition replica assignments based on current RF
         */
        function recalculatePartitionAssignments() {
            const allBrokers = Object.keys(clusterState.brokers);
            const brokerCount = allBrokers.length;
            
            // Separate brokers by site for rack awareness
            const dc1Brokers = allBrokers.filter(id => clusterState.brokers[id].site === 'DC1');
            const dc2Brokers = allBrokers.filter(id => clusterState.brokers[id].site === 'DC2');
            
            // For each partition, assign replicas based on RF and rack awareness setting
            Object.keys(clusterState.partitions).forEach((partitionId, index) => {
                const partition = clusterState.partitions[partitionId];
                const replicas = [];
                
                if (RACK_AWARENESS_ENABLED) {
                    // Rack-aware distribution: alternate DC1/DC2 per partition for balanced risk
                    // P0: DC1=ceil(RF/2), DC2=floor(RF/2)
                    // P1: DC1=floor(RF/2), DC2=ceil(RF/2) 
                    // P2: DC1=ceil(RF/2), DC2=floor(RF/2) ... and so on
                    
                    let dc1Count, dc2Count;
                    if (index % 2 === 0) {
                        // Even partition index: favor DC1
                        dc1Count = Math.ceil(RF_VALUE / 2);
                        dc2Count = Math.floor(RF_VALUE / 2);
                    } else {
                        // Odd partition index: favor DC2
                        dc1Count = Math.floor(RF_VALUE / 2);
                        dc2Count = Math.ceil(RF_VALUE / 2);
                    }
                    
                    // Add DC1 brokers (avoid duplicates)
                    for (let i = 0; i < dc1Count && i < dc1Brokers.length && replicas.length < RF_VALUE; i++) {
                        const brokerIndex = (index + i) % dc1Brokers.length;
                        const brokerId = dc1Brokers[brokerIndex];
                        if (!replicas.includes(brokerId)) {
                            replicas.push(brokerId);
                        }
                    }
                    
                    // Add DC2 brokers (avoid duplicates)
                    for (let i = 0; i < dc2Count && i < dc2Brokers.length && replicas.length < RF_VALUE; i++) {
                        const brokerIndex = (index + i) % dc2Brokers.length;
                        const brokerId = dc2Brokers[brokerIndex];
                        if (!replicas.includes(brokerId)) {
                            replicas.push(brokerId);
                        }
                    }
                    
                    // Fill remaining slots with available brokers if needed
                    while (replicas.length < RF_VALUE && replicas.length < brokerCount) {
                        const remainingBrokers = allBrokers.filter(id => !replicas.includes(id));
                        if (remainingBrokers.length > 0) {
                            const brokerIndex = (index + replicas.length) % remainingBrokers.length;
                            replicas.push(remainingBrokers[brokerIndex]);
                        } else {
                            break;
                        }
                    }
                } else {
                    // Random/Round-robin distribution across all brokers
                    for (let i = 0; i < RF_VALUE && i < brokerCount; i++) {
                        const brokerIndex = (index * RF_VALUE + i) % brokerCount;
                        replicas.push(allBrokers[brokerIndex]);
                    }
                }
                
                // Set leader (first replica) and followers (rest)
                partition.leader = replicas[0];
                partition.followers = replicas.slice(1);
                partition.uleUsed = false; // Reset ULE flag
            });
            
            // Also update the initialState for proper comparison
            Object.keys(initialState.partitions).forEach((partitionId, index) => {
                const partition = initialState.partitions[partitionId];
                const replicas = [];
                
                if (RACK_AWARENESS_ENABLED) {
                    // Rack-aware distribution for initialState (same alternating pattern)
                    let dc1Count, dc2Count;
                    if (index % 2 === 0) {
                        dc1Count = Math.ceil(RF_VALUE / 2);
                        dc2Count = Math.floor(RF_VALUE / 2);
                    } else {
                        dc1Count = Math.floor(RF_VALUE / 2);
                        dc2Count = Math.ceil(RF_VALUE / 2);
                    }
                    
                    // Add DC1 brokers (avoid duplicates)
                    for (let i = 0; i < dc1Count && i < dc1Brokers.length && replicas.length < RF_VALUE; i++) {
                        const brokerIndex = (index + i) % dc1Brokers.length;
                        const brokerId = dc1Brokers[brokerIndex];
                        if (!replicas.includes(brokerId)) {
                            replicas.push(brokerId);
                        }
                    }
                    
                    // Add DC2 brokers (avoid duplicates)
                    for (let i = 0; i < dc2Count && i < dc2Brokers.length && replicas.length < RF_VALUE; i++) {
                        const brokerIndex = (index + i) % dc2Brokers.length;
                        const brokerId = dc2Brokers[brokerIndex];
                        if (!replicas.includes(brokerId)) {
                            replicas.push(brokerId);
                        }
                    }
                    
                    // Fill remaining slots with available brokers if needed
                    while (replicas.length < RF_VALUE && replicas.length < brokerCount) {
                        const remainingBrokers = allBrokers.filter(id => !replicas.includes(id));
                        if (remainingBrokers.length > 0) {
                            const brokerIndex = (index + replicas.length) % remainingBrokers.length;
                            replicas.push(remainingBrokers[brokerIndex]);
                        } else {
                            break;
                        }
                    }
                } else {
                    // Random/Round-robin distribution for initialState
                    for (let i = 0; i < RF_VALUE && i < brokerCount; i++) {
                        const brokerIndex = (index * RF_VALUE + i) % brokerCount;
                        replicas.push(allBrokers[brokerIndex]);
                    }
                }
                
                // Set leader (first replica) and followers (rest)
                partition.leader = replicas[0];
                partition.followers = replicas.slice(1);
                partition.uleUsed = false; // Reset ULE flag
            });
        }

        /**
         * Updates the configuration impact display
         */
        function updateConfigImpact() {
            const diskUsage = document.getElementById('disk_usage');
            const tolerableFailures = document.getElementById('tolerable_failures');
            const configDescription = document.getElementById('config_description');
            const rfImpact = document.getElementById('rf_impact');
            const minIsrImpact = document.getElementById('min_isr_impact');
            const networkTraffic = document.getElementById('network_traffic');
            const storageCost = document.getElementById('storage_cost');
            const riskLevel = document.getElementById('risk_level');
            const availabilityScore = document.getElementById('availability_score');
            
            // Calculate disk usage
            const diskMultiplier = RF_VALUE;
            diskUsage.textContent = `${diskMultiplier}x (${RF_VALUE} Brokers)`;
            
            // Calculate tolerable failures
            const maxFailures = RF_VALUE - MIN_ISR;
            tolerableFailures.textContent = `${maxFailures} brokers`;
            
            // Update description
            configDescription.textContent = 
                `Availability requires: ISR count ≥ Min.ISR. With RF = ${RF_VALUE} and Min.ISR = ${MIN_ISR}, the system can tolerate up to ${maxFailures} broker failures without data loss.`;
            
            // Update RF impact indicator
            let rfImpactText = '';
            if (RF_VALUE === 1) {
                rfImpactText = '💾 Minimal disk usage, ❌ No fault tolerance';
            } else if (RF_VALUE === 2) {
                rfImpactText = '💾 Low disk usage, ⚠️ Basic fault tolerance';
            } else if (RF_VALUE === 3) {
                rfImpactText = '💾 Low disk usage, ⚠️ Limited fault tolerance';
            } else if (RF_VALUE === 4) {
                rfImpactText = '💾 Medium disk usage, ✅ Good fault tolerance';
            } else if (RF_VALUE === 5) {
                rfImpactText = '💾 High disk usage, ✅ Very good fault tolerance';
            } else if (RF_VALUE === 6) {
                rfImpactText = '💾 Maximum disk usage, 🛡️ Maximum fault tolerance';
            }
            rfImpact.textContent = rfImpactText;
            
            // Update Min ISR impact indicator
            let minIsrImpactText = '';
            if (MIN_ISR === 1) {
                minIsrImpactText = '⚡ Fast writes, ⚠️ Risk of data loss';
            } else if (MIN_ISR === 2) {
                minIsrImpactText = '⚡ Good performance, ⚠️ Some risk';
            } else if (MIN_ISR === 3) {
                minIsrImpactText = '⚖️ Balanced performance & safety';
            } else if (MIN_ISR === 4) {
                minIsrImpactText = '🛡️ High safety, ⚠️ Slower writes';
            } else if (MIN_ISR === 5) {
                minIsrImpactText = '🛡️ Very safe, ⚠️ Slow writes';
            } else if (MIN_ISR === 6) {
                minIsrImpactText = '🛡️ Maximum safety, ⚠️ Very slow writes';
            }
            minIsrImpact.textContent = minIsrImpactText;
            
            // Update network and storage impact
            let networkTrafficText = '';
            if (RF_VALUE <= 2) {
                networkTrafficText = 'Low';
            } else if (RF_VALUE <= 4) {
                networkTrafficText = 'Medium';
            } else {
                networkTrafficText = 'High';
            }
            networkTraffic.textContent = networkTrafficText;
            
            storageCost.textContent = `${diskMultiplier}x Base`;
            
            // Calculate risk level and availability
            let riskLevelText = '';
            let riskLevelClass = '';
            let availability = '';
            
            if (MIN_ISR === 1) {
                riskLevelText = 'High';
                riskLevelClass = 'bg-red-100 text-red-800';
                availability = '99.0%';
            } else if (MIN_ISR === 2) {
                riskLevelText = 'Medium';
                riskLevelClass = 'bg-yellow-100 text-yellow-800';
                availability = '99.5%';
            } else if (MIN_ISR === 3) {
                riskLevelText = 'Low';
                riskLevelClass = 'bg-green-100 text-green-800';
                availability = '99.9%';
            } else if (MIN_ISR >= 4) {
                riskLevelText = 'Very Low';
                riskLevelClass = 'bg-green-100 text-green-800';
                availability = '99.99%';
            }
            
            riskLevel.textContent = riskLevelText;
            riskLevel.className = `px-2 py-1 rounded-full text-xs font-bold ${riskLevelClass}`;
            availabilityScore.textContent = availability;
            
            // Recalculate partition assignments when RF changes
            recalculatePartitionAssignments();
            
            // Update rack awareness impact display
            updateRackAwarenessImpact();
            
            // Force render client impact after config update
            setTimeout(() => {
                renderControlPlaneStatus();
                renderClientImpact();
                renderPartitionStatus();
            }, 50);
        }

        // --- Utility Functions ---

        /**
         * Counts the number of UP replicas for a given partition.
         */
        function getISRCount(partitionId) {
            const partition = clusterState.partitions[partitionId];
            const allReplicas = [partition.leader, ...partition.followers];
            let isrCount = 0;
            
            // Check if VIP is down for any site - if so, brokers in that site cannot participate
            const dc1IngressDown = clusterState.services.DC1_INGRESS.status === 'DOWN';
            const dc2IngressDown = clusterState.services.DC2_INGRESS.status === 'DOWN';
            
            // Count available replicas considering VIP status
            for (const brokerId of allReplicas) {
                const broker = clusterState.brokers[brokerId];
                if (broker && broker.status === 'UP') {
                    // Check if broker is in a site with down VIP
                    const brokerSite = broker.site;
                    const isBrokerSiteDown = (brokerSite === 'DC1' && dc1IngressDown) || 
                                           (brokerSite === 'DC2' && dc2IngressDown);
                    
                    // Only count if broker is UP AND its site VIP is also UP
                    if (!isBrokerSiteDown) {
                        isrCount++;
                    }
                }
            }
            
            // Calculate total available brokers in the cluster (for AOP logic)
            let totalAvailableBrokers = 0;
            for (const [brokerId, broker] of Object.entries(clusterState.brokers)) {
                if (broker.status === 'UP') {
                    const brokerSite = broker.site;
                    const isBrokerSiteDown = (brokerSite === 'DC1' && dc1IngressDown) || 
                                           (brokerSite === 'DC2' && dc2IngressDown);
                    if (!isBrokerSiteDown) {
                        totalAvailableBrokers++;
                    }
                }
            }
            
            // AOP Logic: If AOP is enabled, we can promote async replicas to ISR
            if (AOP_VALUE > 0 && isrCount < MIN_ISR) {
                const maxPossibleISR = Math.min(RF_VALUE + AOP_VALUE, totalAvailableBrokers);
                
                // If we have enough brokers available, we can maintain the required ISR
                if (maxPossibleISR >= MIN_ISR) {
                    isrCount = Math.max(isrCount, MIN_ISR);
                }
            }
            
            // Critical Check: If total available brokers < Min.ISR, all partitions should be offline
            if (totalAvailableBrokers < MIN_ISR) {
                isrCount = Math.min(isrCount, totalAvailableBrokers);
            }
            
            return isrCount;
        }

        /**
         * Get total available brokers considering VIP status
         */
        function getTotalAvailableBrokers() {
            const dc1IngressDown = clusterState.services.DC1_INGRESS.status === 'DOWN';
            const dc2IngressDown = clusterState.services.DC2_INGRESS.status === 'DOWN';
            
            let totalAvailableBrokers = 0;
            for (const [brokerId, broker] of Object.entries(clusterState.brokers)) {
                if (broker.status === 'UP') {
                    const brokerSite = broker.site;
                    const isBrokerSiteDown = (brokerSite === 'DC1' && dc1IngressDown) || 
                                           (brokerSite === 'DC2' && dc2IngressDown);
                    if (!isBrokerSiteDown) {
                        totalAvailableBrokers++;
                    }
                }
            }
            return totalAvailableBrokers;
        }

        /**
         * Counts the number of UP KRaft controllers and determines quorum status.
         */
        function checkQuorum() {
            const upControllers = Object.values(clusterState.kraft_controllers).filter(c => c.status === 'UP').length;
            
            // Check if VIPs are down - if so, controllers cannot communicate
            const bothIngressDown = 
                clusterState.services.DC1_INGRESS.status === 'DOWN' &&
                clusterState.services.DC2_INGRESS.status === 'DOWN';
            
            // If both VIPs are down, controllers cannot communicate even if they are UP
            let quorumMaintained = false;
            if (bothIngressDown) {
                console.log('Both VIPs are DOWN - controllers cannot communicate, quorum lost');
                quorumMaintained = false;
            } else {
                quorumMaintained = upControllers >= QUORUM_REQUIRED;
            }
            
            return { upControllers, quorumMaintained };
        }

        /**
         * Finds a healthy follower for a given partition that can be elected as the new leader.
         */
        function findNewLeader(partitionId) {
            const partition = clusterState.partitions[partitionId]; // Use current followers list
            const currentLeader = clusterState.partitions[partitionId].leader;
            const allReplicas = [currentLeader, ...partition.followers];
            
            // Prioritize a replica that is UP and not the current leader (must be ISR/UP to be considered)
            for (const brokerId of allReplicas) {
                // Check if the broker is internally UP
                if (brokerId !== currentLeader && clusterState.brokers[brokerId] && clusterState.brokers[brokerId].status === 'UP') {
                    return brokerId;
                }
            }
            return null; 
        }
        
        /**
         * Helper to get Tailwind classes based on status string.
         */
        function getStatusClasses(status) {
            switch (status) {
                case 'UP':
                    return 'up text-green-600 font-extrabold';
                case 'DOWN':
                    return 'down text-red-600 font-extrabold';
                case 'UNAVAILABLE':
                    return 'unavailable text-gray-600 font-extrabold';
                case 'PARTIAL':
                    return 'partial text-yellow-600 font-extrabold';
                default:
                    return 'text-gray-500';
            }
        }
        
        /**
         * Generates the HTML for a compact, clickable status box.
         */
        function generateControlHtml(id, desc, isUp, type) {
            const elementId = `${type}_${id}`;
            const labelDesc = desc; // Use full description now
            
            // Determine initial state classes
            const statusClass = isUp ? 'up-state' : 'down-state';
            const statusText = isUp ? 'UP' : 'DOWN';
            
            return `
                <div id="${elementId}" onclick="toggleStatus('${type}', '${id}', this)" 
                     class="status-box-toggle ${statusClass}">
                    <span class="truncate block">${labelDesc}</span>
                    <span class="status-text font-extrabold">${statusText}</span>
                </div>
            `;
        }

        /**
         * Toggles the status of a component when clicked and runs the simulation.
         */
        window.toggleStatus = function(type, id, element) {
            let component;
            
            // Determine which object to update in clusterState
            if (type === 'ctrl') {
                component = clusterState.kraft_controllers[id];
            } else if (type === 'brkr') {
                component = clusterState.brokers[id];
            } else if (type === 'svc') {
                component = clusterState.services[id];
            }

            if (component) {
                // Toggle the status
                const newStatus = component.status === 'UP' ? 'DOWN' : 'UP';
                component.status = newStatus;

                // Update the visual representation
                element.classList.toggle('up-state', newStatus === 'UP');
                element.classList.toggle('down-state', newStatus === 'DOWN');
                element.querySelector('.status-text').textContent = newStatus;
                
                // Rerun simulation to see immediate effects in overview/results
                setTimeout(runSimulation, 0);
            }
        }
        
        /**
         * Toggles the status of ALL components in a given site (DC1 or DC2).
         */
        window.toggleSiteStatus = function(site, targetStatus) {
            // 1. Update the state model
            let changeMade = false;
            
            // Controllers
            Object.keys(clusterState.kraft_controllers).forEach(id => {
                if (clusterState.kraft_controllers[id].site === site && clusterState.kraft_controllers[id].status !== targetStatus) {
                    clusterState.kraft_controllers[id].status = targetStatus;
                    changeMade = true;
                }
            });
            // Brokers
            Object.keys(clusterState.brokers).forEach(id => {
                if (clusterState.brokers[id].site === site && clusterState.brokers[id].status !== targetStatus) {
                    clusterState.brokers[id].status = targetStatus;
                    changeMade = true;
                }
            });
            // Services (including Ingress)
            Object.keys(clusterState.services).forEach(id => {
                if (clusterState.services[id].site === site && clusterState.services[id].status !== targetStatus) {
                    clusterState.services[id].status = targetStatus;
                    changeMade = true;
                }
            });

            // 2. Update the UI elements and re-run simulation if changes were made
            if (changeMade) {
                const prefix = site === 'DC1' ? 'A' : 'B';
                
                // Update Controller Toggles
                document.querySelectorAll(`#${site.toLowerCase()}_controllers_container .status-box-toggle`).forEach(element => {
                    const status = clusterState.kraft_controllers[element.id.slice(5)].status;
                    element.classList.toggle('up-state', status === 'UP');
                    element.classList.toggle('down-state', status === 'DOWN');
                    element.querySelector('.status-text').textContent = status;
                });
                
                // Update Broker Toggles
                document.querySelectorAll(`#${site.toLowerCase()}_brokers_container .status-box-toggle`).forEach(element => {
                    const status = clusterState.brokers[element.id.slice(5)].status;
                    element.classList.toggle('up-state', status === 'UP');
                    element.classList.toggle('down-state', status === 'DOWN');
                    element.querySelector('.status-text').textContent = status;
                });

                // Update Service Toggles
                document.querySelectorAll(`#${site.toLowerCase()}_services_container .status-box-toggle`).forEach(element => {
                    const status = clusterState.services[element.id.slice(4)].status;
                    element.classList.toggle('up-state', status === 'UP');
                    element.classList.toggle('down-state', status === 'DOWN');
                    element.querySelector('.status-text').textContent = status;
                });

                setTimeout(runSimulation, 0);
            }
        }
        
        /**
         * Compares current state to initial state and generates a summary of failed components.
         */
        function getFailedComponentsSummary() {
            let summary = ["--- 🛑 Initial Failure Event Summary 🛑 ---"];
            let failedFound = false;
            
            // 1. Controllers
            Object.keys(clusterState.kraft_controllers).forEach(id => {
                if (clusterState.kraft_controllers[id].status === 'DOWN') {
                    summary.push(`- KRaft Controller ${id} (${clusterState.kraft_controllers[id].site}) was manually stopped.`);
                    failedFound = true;
                }
            });

            // 2. Brokers
            Object.keys(clusterState.brokers).forEach(id => {
                if (clusterState.brokers[id].status === 'DOWN') {
                    summary.push(`- Kafka Broker ${id} (${clusterState.brokers[id].site}) was manually stopped.`);
                    failedFound = true;
                }
            });
            
            // 3. Services (including Ingress)
            Object.keys(clusterState.services).forEach(id => {
                if (clusterState.services[id].status === 'DOWN') {
                    summary.push(`- Service ${clusterState.services[id].desc} (${clusterState.services[id].site}) was manually stopped.`);
                    failedFound = true;
                }
            });

            if (!failedFound) {
                summary.push("- No components were manually stopped.");
            }
            
            return summary;
        }

        /**
         * Renders the component controls grouped by site.
         */
        function buildCustomUI() {
            // Get containers for each site/component type
            const dc1_ctrl = document.getElementById('dc1_controllers_container');
            const dc1_brkr = document.getElementById('dc1_brokers_container');
            const dc1_svc = document.getElementById('dc1_services_container');

            const site3_ctrl = document.getElementById('site3_controllers_container');

            const dc2_ctrl = document.getElementById('dc2_controllers_container');
            const dc2_brkr = document.getElementById('dc2_brokers_container');
            const dc2_svc = document.getElementById('dc2_services_container');
            
            dc1_ctrl.innerHTML = dc1_brkr.innerHTML = dc1_svc.innerHTML = '';
            site3_ctrl.innerHTML = '';
            dc2_ctrl.innerHTML = dc2_brkr.innerHTML = dc2_svc.innerHTML = '';


            // Render DC1 Components
            Object.keys(initialState.kraft_controllers).filter(id => initialState.kraft_controllers[id].site === 'DC1').forEach(id => {
                dc1_ctrl.innerHTML += generateControlHtml(id, `C${id.slice(1)}`, initialState.kraft_controllers[id].status === 'UP', 'ctrl');
            });
            Object.keys(initialState.brokers).filter(id => initialState.brokers[id].site === 'DC1').forEach(id => {
                dc1_brkr.innerHTML += generateControlHtml(id, id, initialState.brokers[id].status === 'UP', 'brkr');
            });
            // Move Ingress to top group
            const dc1IngressId = 'DC1_INGRESS';
            const dc1IngressEl = document.getElementById('dc1_ingress_top');
            if (dc1IngressEl && initialState.services[dc1IngressId]) {
                dc1IngressEl.innerHTML = generateControlHtml(dc1IngressId, initialState.services[dc1IngressId].desc, initialState.services[dc1IngressId].status === 'UP', 'svc');
            }
            Object.keys(initialState.services)
                .filter(id => initialState.services[id].site === 'DC1' && id !== dc1IngressId)
                .forEach(id => {
                    dc1_svc.innerHTML += generateControlHtml(id, initialState.services[id].desc, initialState.services[id].status === 'UP', 'svc');
                });

            // Render Site 3 Components
            Object.keys(initialState.kraft_controllers).filter(id => initialState.kraft_controllers[id].site === 'Site3').forEach(id => {
                site3_ctrl.innerHTML += generateControlHtml(id, `C${id.slice(1)} (VM)`, initialState.kraft_controllers[id].status === 'UP', 'ctrl');
            });

            // Render DC2 Components
            Object.keys(initialState.kraft_controllers).filter(id => initialState.kraft_controllers[id].site === 'DC2').forEach(id => {
                dc2_ctrl.innerHTML += generateControlHtml(id, `C${id.slice(1)}`, initialState.kraft_controllers[id].status === 'UP', 'ctrl');
            });
            Object.keys(initialState.brokers).filter(id => initialState.brokers[id].site === 'DC2').forEach(id => {
                dc2_brkr.innerHTML += generateControlHtml(id, id, initialState.brokers[id].status === 'UP', 'brkr');
            });
            const dc2IngressId = 'DC2_INGRESS';
            const dc2IngressEl = document.getElementById('dc2_ingress_top');
            if (dc2IngressEl && initialState.services[dc2IngressId]) {
                dc2IngressEl.innerHTML = generateControlHtml(dc2IngressId, initialState.services[dc2IngressId].desc, initialState.services[dc2IngressId].status === 'UP', 'svc');
            }
            Object.keys(initialState.services)
                .filter(id => initialState.services[id].site === 'DC2' && id !== dc2IngressId)
                .forEach(id => {
                    dc2_svc.innerHTML += generateControlHtml(id, initialState.services[id].desc, initialState.services[id].status === 'UP', 'svc');
                });
            
            // Force render client impact after UI is built
            setTimeout(() => {
                renderClientImpact();
            }, 50);
            
            // NOTE: Min.ISR input removed from UI
        }

        /**
         * Calculates actual risk level based on current cluster status
         */
        function calculateActualRiskLevel() {
            const { quorumMaintained } = checkQuorum();
            const minISR = MIN_ISR;
            let partitionsOffline = 0;
            
            // Count offline partitions
            for (const [pId, pData] of Object.entries(clusterState.partitions)) {
                const isrCount = getISRCount(pId);
                const isAvailable = isrCount >= minISR;
                
                if (!isAvailable) {
                    partitionsOffline++;
                }
            }
            
            // Check if all ingress VIPs are down
            const bothIngressDown = 
                clusterState.services.DC1_INGRESS.status === 'DOWN' &&
                clusterState.services.DC2_INGRESS.status === 'DOWN';
            
            if (bothIngressDown) {
                return { level: 'Critical', class: 'bg-red-100 text-red-800' };
            }
            
            if (!quorumMaintained) {
                return { level: 'High', class: 'bg-red-100 text-red-800' };
            }
            
            if (partitionsOffline === 0) {
                return { level: 'Low', class: 'bg-green-100 text-green-800' };
            } else if (partitionsOffline === 1) {
                return { level: 'Medium', class: 'bg-yellow-100 text-yellow-800' };
            } else if (partitionsOffline === 2) {
                return { level: 'High', class: 'bg-orange-100 text-orange-800' };
            } else {
                return { level: 'Critical', class: 'bg-red-100 text-red-800' };
            }
        }

        /**
         * Calculates actual availability based on current cluster status
         * Uses partition availability ratio for realistic production scenarios
         */
        function calculateActualAvailability() {
            const { quorumMaintained } = checkQuorum();
            const minISR = MIN_ISR;
            let partitionsOnline = 0;
            let totalPartitions = 0;
            
            // Count online/offline partitions
            for (const [pId, pData] of Object.entries(clusterState.partitions)) {
                totalPartitions++;
                const isrCount = getISRCount(pId);
                const isAvailable = isrCount >= minISR;
                
                if (isAvailable) {
                    partitionsOnline++;
                }
            }
            
            const partitionsOffline = totalPartitions - partitionsOnline;
            
            // Check if all ingress VIPs are down
            const bothIngressDown = 
                clusterState.services.DC1_INGRESS.status === 'DOWN' &&
                clusterState.services.DC2_INGRESS.status === 'DOWN';
            
            if (bothIngressDown) {
                return '0%'; // Complete outage if all VIPs are down
            }
            
            // Calculate partition availability ratio (assuming equal traffic distribution)
            const partitionAvailabilityRatio = totalPartitions > 0 ? (partitionsOnline / totalPartitions) : 0;
            
            if (!quorumMaintained) {
                // Quorum lost: control plane unavailable, but data plane may still serve
                if (partitionsOffline === 0) {
                    // All partitions working but no metadata operations
                    return '90%'; // High availability for reads/writes, degraded for admin ops
                } else {
                    // Combine partition ratio with quorum penalty
                    const baseAvailability = partitionAvailabilityRatio * 0.8; // 20% penalty for quorum loss
                    return `${Math.round(baseAvailability * 100)}%`;
                }
            }
            
            // Normal operation: calculate based on partition availability
            if (partitionsOffline === 0) {
                return '99.99%'; // Full availability - all partitions operational
            } else if (totalPartitions > 0) {
                // Calculate actual availability based on partition ratio
                // Note: In production, this assumes equal traffic distribution across partitions
                // For skewed traffic, actual impact would be different
                const availabilityPercent = Math.round(partitionAvailabilityRatio * 100 * 100) / 100;
                return `${availabilityPercent.toFixed(1)}%`;
            } else {
                return '0%';
            }
        }

        /**
         * Renders the overall cluster health status.
         */
        function renderClusterHealth() {
            // Quorum Status
            const { upControllers, quorumMaintained } = checkQuorum();
            const quorumDot = document.getElementById('quorum_status_dot');
            const quorumText = document.getElementById('quorum_status_text');
            const quorumConsensus = document.getElementById('quorum_consensus');
            
            const c5Status = clusterState.kraft_controllers.C5.status;
            
            // Check if VIPs are down
            const bothIngressDown = 
                clusterState.services.DC1_INGRESS.status === 'DOWN' &&
                clusterState.services.DC2_INGRESS.status === 'DOWN';
            
            if (quorumMaintained && !bothIngressDown) {
                if (quorumDot) quorumDot.className = 'status-dot up';
                if (quorumConsensus) {
                    quorumConsensus.className = 'quorum-maintained';
                    quorumConsensus.textContent = `MAINTAINED (${upControllers}/${QUORUM_REQUIRED})`;
                }
            } else {
                if (quorumDot) quorumDot.className = 'status-dot down';
                if (quorumConsensus) {
                    quorumConsensus.className = 'quorum-lost';
                    if (bothIngressDown) {
                        quorumConsensus.textContent = `LOST - VIPs DOWN (${upControllers}/${QUORUM_REQUIRED}) - UNAVAILABLE!`;
                    } else {
                        quorumConsensus.textContent = `LOST (${upControllers}/${QUORUM_REQUIRED}) - UNAVAILABLE!`;
                    }
                }
            }
            if (quorumText) quorumText.innerHTML = `Controller (C5) | ${c5Status}`;
            
            const site3Panel = document.getElementById('site3_panel');
            if (site3Panel) {
                site3Panel.classList.toggle('opacity-50', c5Status === 'DOWN');
            }


            // DC1 & DC2 Health
            ['DC1', 'DC2'].forEach(site => {
                const siteLower = site.toLowerCase();
                const brokers = Object.keys(clusterState.brokers).filter(b => clusterState.brokers[b].site === site);
                const upBrokers = brokers.filter(b => clusterState.brokers[b].status === 'UP').length;
                const totalBrokers = brokers.length;

                const brokerStatusElem = document.getElementById(`${siteLower}_broker_status`);
                const kraftStatusElem = document.getElementById(`${siteLower}_kraft_status`);
                const serviceStatusElem = document.getElementById(`${siteLower}_service_status`);
                const ingressStatusTextElem = document.getElementById(`${siteLower}_ingress_status_text`);
                
                const ingressStatus = clusterState.services[`${site}_INGRESS`].status;

                // Broker Status
                let brokerStatus = 'UP';
                if (upBrokers === 0) brokerStatus = 'DOWN';
                else if (upBrokers < totalBrokers) brokerStatus = 'PARTIAL';
                
                // KRaft Status 
                const siteControllers = Object.values(clusterState.kraft_controllers).filter(c => c.site === site);
                const upKraft = siteControllers.filter(c => c.status === 'UP').length;
                let kraftStatus = 'UP';
                if (upKraft === 0) kraftStatus = 'DOWN';
                else if (upKraft < siteControllers.length) kraftStatus = 'PARTIAL';

                // Service Status (Connect/SR only)
                const connectStatus = clusterState.services[`${site}_CONNECT`].status;
                const srStatus = clusterState.services[`${site}_SR`].status;
                let serviceStatus = connectStatus === 'UP' && srStatus === 'UP' ? 'UP' : 'DOWN';
                
                
                // CRITICAL FIX: Ingress Down means Layer 1 components are UNREACHABLE/UNAVAILABLE
                const panel = document.getElementById(`${siteLower}_panel`);
                const isSiteUnreachable = ingressStatus === 'DOWN';
                
                if (isSiteUnreachable) {
                    // OVERRIDE visual status to UNAVAILABLE
                    brokerStatus = 'UNAVAILABLE';
                    kraftStatus = 'UNAVAILABLE';
                    serviceStatus = 'UNAVAILABLE';
                }

                if (brokerStatusElem) {
                    brokerStatusElem.className = getStatusClasses(brokerStatus);
                    brokerStatusElem.textContent = brokerStatus;
                    
                    // Broker display list update
                    const brokerList = site === 'DC1' ? '(A1, A2, A3)' : '(B1, B2, B3)';
                    if (brokerStatusElem.previousSibling) {
                        brokerStatusElem.previousSibling.textContent = `Broker ${brokerList}: `;
                    }
                }

                if (kraftStatusElem) {
                    kraftStatusElem.className = getStatusClasses(kraftStatus);
                    kraftStatusElem.textContent = kraftStatus;
                }

                if (serviceStatusElem) {
                    serviceStatusElem.className = getStatusClasses(serviceStatus);
                    serviceStatusElem.textContent = serviceStatus;
                }

                // Ingress Status Text Update (Layer 1)
                if (ingressStatusTextElem) {
                    ingressStatusTextElem.textContent = ingressStatus;
                    ingressStatusTextElem.className = ingressStatus === 'UP' ? 'text-green-600 font-extrabold' : 'text-red-600 font-extrabold';
                }


                // Panel Highlighting: Dim if unreachable from outside
                if (panel) {
                    panel.classList.toggle('opacity-50', isSiteUnreachable);
                }
            });
            
            // Update Min.ISR display in the results column
            const minIsrElement = document.getElementById('display_min_isr');
            if (minIsrElement) {
                minIsrElement.textContent = MIN_ISR;
            }
            
            // Update actual availability score
            const availabilityElement = document.getElementById('availability_score');
            if (availabilityElement) {
                const actualAvailability = calculateActualAvailability();
                availabilityElement.textContent = actualAvailability;
                
                // Change color based on availability
                if (actualAvailability === '0%') {
                    availabilityElement.className = 'text-red-600 font-bold';
                } else if (actualAvailability === '25%' || actualAvailability === '40%') {
                    availabilityElement.className = 'text-red-600 font-bold';
                } else if (actualAvailability === '60%' || actualAvailability === '70%') {
                    availabilityElement.className = 'text-yellow-600 font-bold';
                } else if (actualAvailability === '75%' || actualAvailability === '85%') {
                    availabilityElement.className = 'text-orange-600 font-bold';
                } else if (actualAvailability === '95%') {
                    availabilityElement.className = 'text-blue-600 font-bold';
                } else {
                    availabilityElement.className = 'text-green-600 font-bold';
                }
            }
            
            // Update actual risk level
            const riskLevelElement = document.getElementById('risk_level');
            if (riskLevelElement) {
                const actualRisk = calculateActualRiskLevel();
                riskLevelElement.textContent = actualRisk.level;
                riskLevelElement.className = `px-2 py-1 rounded-full text-xs font-bold ${actualRisk.class}`;
            }
        }

        /**
         * Renders the control plane status based on KRaft controller health
         */
        function renderControlPlaneStatus() {
            const container = document.getElementById('control_plane_status');
            if (!container) {
                console.error('Control plane status container not found!');
                return;
            }
            
            const { quorumMaintained, upControllers } = checkQuorum();
            const bothIngressDown = 
                clusterState.services.DC1_INGRESS.status === 'DOWN' &&
                clusterState.services.DC2_INGRESS.status === 'DOWN';
            
            let statusText, statusClass, statusBgClass;
            
            if (bothIngressDown) {
                statusText = `❌ Control Plane: UNAVAILABLE - All Ingress VIPs DOWN`;
                statusClass = 'text-red-800';
                statusBgClass = 'bg-red-100';
            } else if (!quorumMaintained) {
                statusText = `❌ Control Plane: LOST - KRaft Quorum Failed (${upControllers}/${QUORUM_REQUIRED} controllers UP)`;
                statusClass = 'text-red-800';
                statusBgClass = 'bg-red-100';
            } else {
                statusText = `✅ Control Plane: HEALTHY - KRaft Quorum Maintained (${upControllers}/${QUORUM_REQUIRED} controllers UP)`;
                statusClass = 'text-green-800';
                statusBgClass = 'bg-green-100';
            }
            
            container.innerHTML = `
                <div class="${statusBgClass} p-3 rounded-lg">
                    <p class="font-semibold ${statusClass}">${statusText}</p>
                    <p class="text-sm text-gray-600 mt-1">
                        Control Plane manages: Topic creation, Leader elections, ACL changes, Metadata operations
                    </p>
                </div>
            `;
        }

        /**
         * Renders the partition leader/follower status.
         */
        function renderPartitionStatus() {
            const container = document.getElementById('partition_status');
            if (!container) {
                console.error('Partition status container not found!');
                return;
            }
            
            container.innerHTML = ''; // Clear previous state
            const minISR = MIN_ISR; // Use constant
            const uncleanEnabled = UNCLEAN_ENABLED; // Use constant
            const { quorumMaintained } = checkQuorum();
            const bothIngressDown =
                clusterState.services.DC1_INGRESS.status === 'DOWN' &&
                clusterState.services.DC2_INGRESS.status === 'DOWN';

            // Check total available brokers considering VIP status
            const totalAvailableBrokers = getTotalAvailableBrokers();
            
            // If no brokers are available (all VIPs down or no brokers up), partitions are unreachable
            if (totalAvailableBrokers === 0) {
                for (const [pId] of Object.entries(clusterState.partitions)) {
                    const card = `
                        <div class="p-3 rounded-xl shadow-md border bg-red-50 border-gray-200 min-h-[100px]">
                            <h4 class="font-extrabold text-sm mb-1 text-gray-800">${pId}</h4>
                            <p class="text-xs font-semibold text-red-800">No Available Brokers: All Ingress VIPs DOWN or No Brokers UP. Partition is <strong>Unreachable/Offline</strong> for clients.</p>
                            <p class="text-[10px] text-gray-600 mt-1">Note: Equivalent to complete cluster failure - no brokers accessible.</p>
                        </div>
                    `;
                    container.innerHTML += card;
                }
                return;
            }

            // Check if partition data exists
            if (!clusterState.partitions || Object.keys(clusterState.partitions).length === 0) {
                console.error('No partition data found in clusterState.partitions');
                container.innerHTML = '<div class="p-3 rounded-xl shadow-md border bg-red-100 border-gray-200 min-h-[100px]"><h4 class="font-extrabold text-sm mb-1 text-gray-800">Error</h4><p class="text-xs font-semibold text-red-800">No partition data available</p></div>';
                return;
            }
            
            for (const [pId, pData] of Object.entries(clusterState.partitions)) {
                
                // Find the initial leader from the start state
                const initialLeader = initialState.partitions[pId].leader;
                const currentLeader = clusterState.partitions[pId].leader; // Current leader after election logic has run
                const currentLeaderSite = clusterState.brokers[currentLeader].site;

                // 1. Calculate ISR Count based on current state
                const isrCount = getISRCount(pId);
                const isAvailable = isrCount >= minISR;

                let leaderText;
                let leaderColorClass;
                let leaderBgClass;

                // Determine if the initial leader is internally down
                const initialLeaderIsInternallyDown = clusterState.brokers[initialLeader].status === 'DOWN';
                
                // Check if a leader change occurred
                const leaderChanged = currentLeader !== initialLeader;


                if (!isAvailable) {
                    // --- PARTITION OFFLINE (RED) - ISR < Min.ISR ---
                    const failedLeaderText = initialLeaderIsInternallyDown ? `<span class="font-extrabold text-red-700">${initialLeader} (Failed)</span>` : initialLeader;
                    
                    // According to Kafka logic: If ISR < Min.ISR, partition is OFFLINE regardless of leader availability
                    if (quorumMaintained) {
                        leaderText = `Leader Failed: ${failedLeaderText}. ISR Count (${isrCount}) < Min.ISR (${minISR}). **OFFLINE**`;
                        leaderColorClass = 'text-red-800';
                        leaderBgClass = 'bg-red-100';
                    } else {
                        // No quorum, cannot elect new leader - check if data is actually available
                        if (isrCount === 0) {
                            // No in-sync replicas at all - truly offline
                            leaderText = `Leader Failed: ${failedLeaderText}. Control Plane LOST (no election possible). ISR Count (${isrCount}) < Min.ISR (${minISR}). **OFFLINE**`;
                            leaderColorClass = 'text-red-800';
                            leaderBgClass = 'bg-red-100';
                    } else {
                        // ISR < Min.ISR - partition should be offline regardless of control plane
                        const aopText = AOP_VALUE > 0 ? ` (AOP=${AOP_VALUE} enabled)` : '';
                        leaderText = `Leader Failed: ${failedLeaderText}. Control Plane LOST (no election possible). ISR Count (${isrCount}) < Min.ISR (${minISR})${aopText}. **OFFLINE**`;
                        leaderColorClass = 'text-red-800';
                        leaderBgClass = 'bg-red-100';
                    }
                    }
                
                } else if (!quorumMaintained && initialLeaderIsInternallyDown && !leaderChanged) {
                    // --- LEADER FAILED - check if data is actually available ---
                    if (isrCount === 0) {
                        // No in-sync replicas at all - truly offline
                        leaderText = `Leader Failed: ${initialLeader}. Control Plane LOST (no election possible). ISR Count: ${isrCount} (Min.ISR: ${minISR}). **OFFLINE**`;
                        leaderColorClass = 'text-red-800';
                        leaderBgClass = 'bg-red-100';
                    } else {
                        // ISR < Min.ISR - partition should be offline regardless of control plane
                        const aopText = AOP_VALUE > 0 ? ` (AOP=${AOP_VALUE} enabled)` : '';
                        leaderText = `Leader Failed: ${initialLeader}. Control Plane LOST (no election possible). ISR Count: ${isrCount} (Min.ISR: ${minISR})${aopText}. **OFFLINE**`;
                        leaderColorClass = 'text-red-800';
                        leaderBgClass = 'bg-red-100';
                    }

                } else if (!quorumMaintained) {
                    // --- DATA PLANE AVAILABLE BUT DEGRADED (YELLOW/DEGRADED) ---
                    // Partitions still serve traffic while the current leader is alive; elections/changes are blocked
                    leaderText = `✅ Data Operations: AVAILABLE with Leader: ${currentLeader} (${currentLeaderSite}). ISR Count: ${isrCount} (Min.ISR: ${minISR})`;
                    leaderColorClass = 'text-yellow-800';
                    leaderBgClass = 'bg-yellow-50';

                } else if (leaderChanged) {
                    // --- FAILOVER SUCCESSFUL (YELLOW with PULSING ANIMATION) ---
                    // Text coloring for emphasis on the change event
                    const newLeaderText = `<span class="font-extrabold text-indigo-700 animate-pulse">${currentLeader}</span>`;
                    // Check if the initial leader was actually the one that failed (not just a re-election from a non-failed broker)
                    const failedLeaderText = initialLeaderIsInternallyDown ? `(Old Leader ${initialLeader} <span class="text-red-700 font-extrabold">Failed</span>)` : '';
                    
                    if (uncleanEnabled) {
                        // ORANGE: Unclean Election Risk with pulsing
                        leaderText = `⚠️ ULE Election: New Leader ${newLeaderText} (${currentLeaderSite}). ${failedLeaderText}. **RISKING DATA LOSS**`;
                        leaderColorClass = 'text-orange-800';
                        leaderBgClass = 'bg-yellow-200 border-2 border-orange-300 animate-pulse'; // Pulsing border and background
                    } else {
                         // YELLOW: Clean Election Successful with pulsing
                        leaderText = `🔄 Leader Changed! New Leader: ${newLeaderText} (${currentLeaderSite}) ${failedLeaderText}`;
                        leaderColorClass = 'text-yellow-800';
                        leaderBgClass = 'bg-yellow-100 border-2 border-yellow-400 animate-pulse'; // Pulsing border and background
                    }
                
                } else if (initialLeaderIsInternallyDown) {
                    // This case should be rare if logic is perfect, but kept for safety.
                    leaderText = `Leader Failed: ${initialLeader}. Election Failed (No ISR available).`;
                    leaderColorClass = 'text-red-800';
                    leaderBgClass = 'bg-red-100';

                } else {
                    // --- STABLE (GREEN) ---
                    // Check if this is the same leader as initial (no change)
                    const isStableLeader = currentLeader === initialLeader;
                    const leaderDisplayText = isStableLeader ? 
                        `<span class="font-extrabold text-green-700">${currentLeader}</span>` : 
                        `<span class="font-extrabold text-green-700">${currentLeader}</span>`;
                    
                    leaderText = `✅ Stable Leader: ${leaderDisplayText} (${currentLeaderSite}). ISR Count: ${isrCount} (Min.ISR: ${minISR})`;
                    leaderColorClass = 'text-green-800';
                    leaderBgClass = isStableLeader ? 'bg-green-100' : 'bg-green-100 border-2 border-green-300';
                }

                const allReplicas = clusterState.partitions[pId].leader + ', ' + clusterState.partitions[pId].followers.join(', ');

                // Add animation class for leader changes
                const animationClass = leaderChanged ? 'leader-change-animation' : '';
                const changeIndicatorClass = leaderChanged ? 'change-indicator' : '';

                const card = `
                    <div class="p-3 rounded-xl shadow-md border ${leaderBgClass} border-gray-200 min-h-[100px] ${animationClass} ${changeIndicatorClass}">
                        <h4 class="font-extrabold text-sm mb-1 text-gray-800">${pId}</h4>
                        <p class="text-xs font-semibold ${leaderColorClass}">${leaderText}</p>
                        <p class="text-[10px] text-gray-600 mt-1">Replicas (RF=${RF_VALUE}${AOP_VALUE > 0 ? ` + AOP=${AOP_VALUE}` : ''}): ${allReplicas}</p>
                        ${leaderChanged ? '<div class="mt-2 text-[10px] text-orange-600 font-semibold">⚠️ Leader Election Completed</div>' : ''}
                    </div>
                `;
                container.innerHTML += card;
            }
        }

        // --- Core Simulation Logic ---

        function updateStateAfterFailover(summary) {
            const minISR = MIN_ISR;
            const uncleanEnabled = UNCLEAN_ENABLED;
            
            let newSequence = summary; 

            // Temporary variable to hold the original state of DC2 components before the override for KRaft logic
            const originalDC2Brokers = {};
            const originalDC2Controllers = {};
            
            // CRITICAL STEP: OCP Ingress Dependency for KRaft (Symmetric DC1/DC2)
            const dc1IngressDown = clusterState.services.DC1_INGRESS.status === 'DOWN';
            const dc2IngressDown = clusterState.services.DC2_INGRESS.status === 'DOWN';

            const originalDC1Brokers = {};
            const originalDC1Controllers = {};

            if (dc1IngressDown) {
                newSequence.push("--- CRITICAL ADJUSTMENT: DC1 Ingress Dependency ---");
                newSequence.push(`- Ingress VIP DC1 is DOWN. OCP gateway unavailable - all containerized services unreachable.`);
                newSequence.push(`- This is equivalent to DC1 site failure - VIP Ingress is the entry point to all OCP services.`);

                ['C1', 'C2'].forEach(id => {
                    originalDC1Controllers[id] = clusterState.kraft_controllers[id].status;
                    if (clusterState.kraft_controllers[id].status === 'UP') {
                        clusterState.kraft_controllers[id].status = 'DOWN';
                        newSequence.push(`- KRaft Controller ${id} (DC1) is logically marked DOWN - unreachable via OCP.`);
                    }
                });
                ['A1', 'A2', 'A3'].forEach(id => {
                    originalDC1Brokers[id] = clusterState.brokers[id].status;
                    if (clusterState.brokers[id].status === 'UP') {
                        clusterState.brokers[id].status = 'DOWN';
                        newSequence.push(`- Kafka Broker ${id} (DC1) is logically marked DOWN - unreachable via OCP.`);
                    }
                });
            }

            if (dc2IngressDown) {
                newSequence.push("--- CRITICAL ADJUSTMENT: DC2 Ingress Dependency ---");
                newSequence.push(`- Ingress VIP DC2 is DOWN. OCP gateway unavailable - all containerized services unreachable.`);
                newSequence.push(`- This is equivalent to DC2 site failure - VIP Ingress is the entry point to all OCP services.`);
                
                // Force DC2 components to DOWN status for the purpose of KRaft decision-making (Leader Election)
                ['C3', 'C4'].forEach(id => { 
                    originalDC2Controllers[id] = clusterState.kraft_controllers[id].status;
                    if (clusterState.kraft_controllers[id].status === 'UP') {
                        clusterState.kraft_controllers[id].status = 'DOWN';
                        newSequence.push(`- KRaft Controller ${id} (DC2) is logically marked DOWN - unreachable via OCP.`);
                    }
                });
                ['B1', 'B2', 'B3'].forEach(id => {
                    originalDC2Brokers[id] = clusterState.brokers[id].status;
                    if (clusterState.brokers[id].status === 'UP') {
                        clusterState.brokers[id].status = 'DOWN';
                        newSequence.push(`- Kafka Broker ${id} (DC2) is logically marked DOWN - unreachable via OCP.`);
                    }
                });
            }

            // Recalculate Quorum after potential forced failures (if any)
            const { upControllers, quorumMaintained } = checkQuorum();
            
            newSequence.push("--- KRaft Failover Sequence Execution ---");
            
            // 1.1 Quorum Check
            newSequence.push(`1.1. KRaft Check: ${QUORUM_SIZE} Controllers configured. Minimum required for Quorum is ${QUORUM_REQUIRED}. Current UP: ${upControllers}.`);

            if (!quorumMaintained) {
                newSequence.push("❌ Quorum Lost! (Controllers UP &lt; 3)"); 
                newSequence.push("🛑 Control Plane Status: Metadata frozen. Leader Elections, Topic/ACL changes are blocked.");
                newSequence.push("⚠️ Data Plane Status: Existing leaders (if UP) continue serving, but any leader failure will lead to partition unavailability.");
            } else {
                newSequence.push("✅ Quorum Maintained! (Control plane is fully operational.)");
            }
            
            newSequence.push(`--- Data Plane Check (RF=${RF_VALUE}, Min.ISR=${MIN_ISR}, ULE=${uncleanEnabled ? 'ON' : 'OFF'}) ---`);

            // Iterate over partitions to check for required leader election
            for (const [pId, pData] of Object.entries(initialState.partitions)) {
                const initialLeader = initialState.partitions[pId].leader;
                
                // If the initial leader is DOWN, election is triggered (due to manual selection OR Ingress-forced failure)
                // Use the clusterState *after* the temporary ingress override
                const isFailoverTriggered = clusterState.brokers[initialLeader].status === 'DOWN'; 
                
                let currentISRCount = getISRCount(pId);

                if (isFailoverTriggered) {
                    newSequence.push(`1. Detected: Partition ${pId} Leader (${initialLeader}) failed/unreachable. ISR Count drops to ${currentISRCount}.`);
                    
                    // --- Case 1: Broker Failure and Quorum is UP ---
                    if (quorumMaintained) {
                        const newLeaderId = findNewLeader(pId); // Finds next UP broker (ISR candidate)
                        
                        if (newLeaderId) {
                            // CLEAN ELECTION SUCCESSFUL (ULE is irrelevant here, as an ISR candidate was found)
                             newSequence.push(`2. KRaft Sequence: Controller finds ${newLeaderId} (available ISR replica in DC1) and initiates Leader Election.`);
                             
                            // **CRITICAL STATE UPDATE:** Update State
                            clusterState.partitions[pId].leader = newLeaderId;
                            clusterState.partitions[pId].uleUsed = false; // Clean election - no ULE
                            const newISRCount = getISRCount(pId); // Recalculate ISR after new leader is chosen
                            
                            if (newISRCount >= minISR) {
                                newSequence.push(`3. Result: Election successful. New Leader ${newLeaderId}. ISR Count (${newISRCount}) $\\geq$ Min.ISR (${minISR}). Partition is **Available** (RPO=0 maintained).`);
                                newSequence.push(`4. Kafka Clients: Metadata Refresh and redirect to the New Leader.`);
                            } else {
                                // Election occurred, but Min.ISR failed immediately after.
                                newSequence.push(`3. Result: Election successful, but ISR Count (${newISRCount}) &lt; Min.ISR (${minISR}). Partition is now **Offline** (Producer Blocked).`);
                                newSequence.push(`4. Kafka Clients: Producer/Consumer receive **NotEnoughReplicas** error.`);
                            }
                        } else {
                            // No available ISR found. Check ULE condition.
                            if (uncleanEnabled) {
                                // ULE enabled. Select the remaining broker (any UP replica)
                                const remainingBrokers = Object.keys(clusterState.brokers).filter(b => b !== initialLeader && clusterState.brokers[b].status === 'UP');
                                if (remainingBrokers.length > 0) {
                                    // Pick the first remaining UP broker (Unclean Leader)
                                    const uncleanLeader = remainingBrokers[0]; 
                                    clusterState.partitions[pId].leader = uncleanLeader;
                                    clusterState.partitions[pId].uleUsed = true; // Mark ULE was used
                                    const newISRCount = getISRCount(pId);
                                    
                                    newSequence.push(`2. KRaft Sequence: No ISR found. ULE is ON. Electing ${uncleanLeader} as Unclean Leader.`);
                                    newSequence.push(`3. Result: Partition is **Available** (${newISRCount}/${minISR}) but **RISKS DATA LOSS** (Unclean Election).`);
                                    newSequence.push(`4. Kafka Clients: Metadata Refresh and redirect to the Unclean Leader.`);
                                } else {
                                    // ULE enabled but NO broker left.
                                    clusterState.partitions[pId].uleUsed = false;
                                    newSequence.push(`2. KRaft Sequence: ULE failed. No remaining broker found.`);
                                    newSequence.push(`3. Result: Partition ${pId} remains **Offline**.`);
                                    newSequence.push(`4. Kafka Clients: Producer/Consumer receive **NotEnoughReplicas** error.`);
                                }
                            } else {
                                // No new ISR found and ULE is disabled. (SAFE FAIL)
                                newSequence.push(`2. KRaft Sequence: Controller failed to find an available In-Sync Replica (ISR). ULE is Disabled.`);
                                newSequence.push(`3. Result: Partition ${pId} is **Offline** (Stuck).`);
                                newSequence.push(`4. Kafka Clients: Producer/Consumer receive **NotEnoughReplicas** error.`);
                            }
                        }
                    } 
                    
                    // --- Case 2: Quorum Loss ---
                    else if (!quorumMaintained) {
                        newSequence.push("2. KRaft Blocked: Quorum destroyed. New Leader cannot be elected.");
                        newSequence.push(`3. Result: Partition ${pId} remains Offline/Unavailable. Clients receive persistent Errors.`);
                    }
                } else {
                    // Leader remains operational (or unreachable externally, but internally fine)
                    newSequence.push(`Partition ${pId}: Leader (${initialLeader}) remains operational. ISR Count: ${currentISRCount}.`);
                }
            }
            
            // FINAL STEP: Revert the status of the forced DOWN components back to their actual UP/DOWN state for the next run and display
            if (dc1IngressDown) {
                ['C1', 'C2'].forEach(id => { clusterState.kraft_controllers[id].status = originalDC1Controllers[id]; });
                ['A1', 'A2', 'A3'].forEach(id => { clusterState.brokers[id].status = originalDC1Brokers[id]; });
                newSequence.push(`--- DC1 Component State Restored ---`);
                newSequence.push(`- Note: Brokers A1-A3 are internally UP but remain externally unreachable via Ingress VIP.`);
            }
            if (dc2IngressDown) {
                ['C3', 'C4'].forEach(id => { clusterState.kraft_controllers[id].status = originalDC2Controllers[id]; });
                ['B1', 'B2', 'B3'].forEach(id => { clusterState.brokers[id].status = originalDC2Brokers[id]; });
                newSequence.push(`--- DC2 Component State Restored ---`);
                newSequence.push(`- Note: Brokers B1-B3 are internally UP but remain externally unreachable via Ingress VIP.`);
            }
            return newSequence;
        }
        
        // **********************************************
        // (Other utility functions like readCustomState, toggleStatus, etc. remain the same)
        // **********************************************

        /**
         * Reads component states from the custom UI and updates clusterState.
         */
        function readCustomState() {
            // Start by resetting to a clean UP state
            let newState = JSON.parse(JSON.stringify(initialState));

            // Iterate through all control elements and set status in newState
            const controls = document.querySelectorAll('.status-box-toggle');
            console.log('Found controls:', controls.length);
            
            controls.forEach(control => {
                const idParts = control.id.split('_');
                const type = idParts[0];
                const id = idParts.slice(1).join('_'); // Rejoin in case of IDs like DC1_CONNECT

                const status = control.classList.contains('up-state') ? 'UP' : 'DOWN';
                console.log(`Control ${control.id}: type=${type}, id=${id}, status=${status}`);

                if (type === 'ctrl') {
                    if (newState.kraft_controllers[id]) {
                        newState.kraft_controllers[id].status = status;
                        console.log(`Updated controller ${id} to ${status}`);
                    }
                } else if (type === 'brkr') {
                    if (newState.brokers[id]) {
                        newState.brokers[id].status = status;
                        console.log(`Updated broker ${id} to ${status}`);
                    }
                } else if (type === 'svc') {
                    if (newState.services[id]) {
                        newState.services[id].status = status;
                        console.log(`Updated service ${id} to ${status}`);
                    }
                }
            });

            console.log('Final newState:', newState);
            return newState;
        }
        
        /**
         * Main function to run the custom simulation.
         */
        window.runSimulation = function() {
            // 1. Read the current state from the UI elements
            const currentState = readCustomState();
            
            // 2. Set the initial partition state for the new run
            // This is essential so the logic always compares against the clean initial leader
            clusterState = JSON.parse(JSON.stringify(currentState));
            clusterState.partitions = JSON.parse(JSON.stringify(initialState.partitions)); 

            // 3. Execute Failover Sequence
            const summary = getFailedComponentsSummary(); // Get summary first
            
            const failoverSteps = updateStateAfterFailover(summary); // Pass summary to be the log start
            
            // 4. Render UI & Determine Client Impact
            renderClusterHealth();
            renderControlPlaneStatus();
            renderPartitionStatus();
            renderClientImpact(); 
            renderSequenceLog(failoverSteps);
        }

        /**
         * Special case for Restore All UP button
         */
        window.runScenario = function(scenarioId) {
            if (scenarioId === 5) {
                // Restore logic - make sure to use current RF configuration
                clusterState = JSON.parse(JSON.stringify(initialState));
                
                // Recalculate partition assignments with current RF
                recalculatePartitionAssignments();
                
                // CRITICAL: Update all UI elements to show UP state
                document.querySelectorAll('.status-box-toggle').forEach(element => {
                    element.classList.add('up-state');
                    element.classList.remove('down-state');
                    element.querySelector('.status-text').textContent = 'UP';
                });
                
                // Keep Rack Awareness at current state - only restore components
                
                const log = [
                    "--- 🛑 Initial Failure Event Summary 🛑 ---", 
                    "- No components were manually stopped.", 
                    "--- KRaft Failover Sequence Execution ---", 
                    `1.1. KRaft Check: ${QUORUM_SIZE} Controllers configured. Minimum required for Quorum is ${QUORUM_REQUIRED}. Current UP: ${QUORUM_SIZE}.`,
                    "✅ Quorum Maintained! (Control plane is fully operational.)",
                    `--- Data Plane Check (RF=${RF_VALUE}, Min.ISR=${MIN_ISR}, ULE=${UNCLEAN_ENABLED ? 'ON' : 'OFF'}) ---`,
                    "Event: Cluster restoration initiated.",
                    "Result: Cluster restored to full operational status."
                ];
                
                renderClusterHealth();
                renderControlPlaneStatus();
                renderPartitionStatus();
                renderClientImpact(); 
                renderSequenceLog(log);
            }
        }


        function renderClientImpact() {
            
            // Check if elements exist
            const producerEl = document.getElementById('producer_impact');
            const consumerEl = document.getElementById('consumer_impact');
            const serviceEl = document.getElementById('service_impact');
            
            const { quorumMaintained } = checkQuorum();
            let producerMsg = "";
            let consumerMsg = "";
            let serviceMsg = "";

            const minISR = MIN_ISR;
            const uncleanEnabled = UNCLEAN_ENABLED;
            let partitionsOffline = 0;
            let leadersFailed = 0;
            let ingressDownCount = 0;
            let uncleanUsed = false;

            
            // Analyze partition availability after simulation logic has run
            for (const [pId, pData] of Object.entries(initialState.partitions)) {
                
                const isrCount = getISRCount(pId);
                const isAvailable = isrCount >= minISR;
                const initialLeader = initialState.partitions[pId].leader;
                const currentLeader = clusterState.partitions[pId].leader;

                if (clusterState.brokers[initialLeader].status === 'DOWN') {
                    leadersFailed++;
                }
                
                if (!isAvailable) {
                    partitionsOffline++;
                }

                // Check if ULE was actually used (tracked during election process)
                if (clusterState.partitions[pId].uleUsed === true) {
                    uncleanUsed = true;
                }
            }
            
            if (clusterState.services.DC1_INGRESS.status === 'DOWN') ingressDownCount++;
            if (clusterState.services.DC2_INGRESS.status === 'DOWN') ingressDownCount++;

            
            // --- Quorum Check ---
            // Build compact badges
            const red = '<span class="inline-block w-2.5 h-2.5 rounded-sm bg-red-500 mr-2 align-middle"></span>';
            const yellow = '<span class="inline-block w-2.5 h-2.5 rounded-sm bg-yellow-400 mr-2 align-middle"></span>';
            const green = '<span class="inline-block w-2.5 h-2.5 rounded-sm bg-emerald-500 mr-2 align-middle"></span>';

            const bothIngressDown =
                clusterState.services.DC1_INGRESS.status === 'DOWN' &&
                clusterState.services.DC2_INGRESS.status === 'DOWN';

            console.log('VIP Status Check in renderClientImpact:', {
                DC1_INGRESS: clusterState.services.DC1_INGRESS.status,
                DC2_INGRESS: clusterState.services.DC2_INGRESS.status,
                bothIngressDown: bothIngressDown
            });

            // Check total available brokers considering VIP status
            const totalAvailableBrokers = getTotalAvailableBrokers();
            
            // If no brokers are available, all operations are blocked
            if (totalAvailableBrokers === 0) {
                console.log('No available brokers - showing unavailable status');
                const extMsg = `${red} <span class=\"font-medium\">Cluster:</span> No available brokers — All operations blocked`;
                producerMsg = `<div class=\"space-y-1\">${extMsg}<br>${red} <span class=\"font-medium\">Data plane:</span> Writes unavailable (no brokers accessible)</div>`;
                consumerMsg = `<div class=\"space-y-1\">${extMsg}<br>${red} <span class=\"font-medium\">Data plane:</span> Reads unavailable (no brokers accessible)</div>`;
                serviceMsg = `<div class=\"space-y-1\">${extMsg}<br>${red} <span class=\"font-medium\">Data plane:</span> Connect tasks unavailable (no brokers accessible)</div>`;
            } else if (!quorumMaintained) {
                console.log('Quorum Lost but VIPs UP - showing degraded status');
                const controlMsg = `${yellow} <span class=\"font-medium\">Control Plane:</span> ❌ UNAVAILABLE (Metadata operations, Topic creation, ACL changes blocked)`;
                
                // Check if any partitions are offline (ISR count < Min.ISR)
                let hasOfflinePartitions = false;
                for (const [pId, pData] of Object.entries(initialState.partitions)) {
                    const isrCount = getISRCount(pId);
                    if (isrCount < MIN_ISR) {
                        hasOfflinePartitions = true;
                        break;
                    }
                }
                
                let dataMsg, producerMsg, consumerMsg, serviceMsg;
                if (hasOfflinePartitions) {
                    dataMsg = `${red} <span class=\"font-medium\">Data Plane:</span> ❌ UNAVAILABLE (ISR count < Min.ISR - Write operations blocked)`;
                    producerMsg = `<div class=\"space-y-1\">${controlMsg}<br>${dataMsg}<br>${red} <span class=\"font-medium\">Impact:</span> Cannot create new topics, write operations unavailable</div>`;
                    consumerMsg = `<div class=\"space-y-1\">${controlMsg}<br>${dataMsg}<br>${yellow} <span class=\"font-medium\">Impact:</span> Cannot create new topics, read operations may work from remaining replicas</div>`;
                    serviceMsg = `<div class=\"space-y-1\">${controlMsg}<br>${dataMsg}<br>${red} <span class=\"font-medium\">Impact:</span> Connect tasks unavailable, no new tasks can be created</div>`;
                } else {
                    dataMsg = `${yellow} <span class=\"font-medium\">Data Plane:</span> ⚠️ DEGRADED (Read/Write operations limited due to leader failure)`;
                    producerMsg = `<div class=\"space-y-1\">${controlMsg}<br>${dataMsg}<br>${yellow} <span class=\"font-medium\">Impact:</span> Cannot create new topics, limited write capability on existing topics</div>`;
                    consumerMsg = `<div class=\"space-y-1\">${controlMsg}<br>${dataMsg}<br>${yellow} <span class=\"font-medium\">Impact:</span> Cannot create new topics, limited read capability on existing topics</div>`;
                    serviceMsg = `<div class=\"space-y-1\">${controlMsg}<br>${dataMsg}<br>${yellow} <span class=\"font-medium\">Impact:</span> Existing Connect tasks may be affected, no new tasks can be created</div>`;
                }

                if (producerEl) {
                    producerEl.innerHTML = `<span class="font-bold">Producer (Write)</span><br>${producerMsg}`;
                    console.log('Producer impact set (VIP DOWN):', producerMsg);
                } else {
                    console.error('Producer impact element not found!');
                }
                
                if (consumerEl) {
                    consumerEl.innerHTML = `<span class="font-bold">Consumer (Read)</span><br>${consumerMsg}`;
                    console.log('Consumer impact set (VIP DOWN):', consumerMsg);
                } else {
                    console.error('Consumer impact element not found!');
                }
                
                if (serviceEl) {
                    serviceEl.innerHTML = `<span class="font-bold">Connect/SR</span><br>${serviceMsg}`;
                    console.log('Service impact set (VIP DOWN):', serviceMsg);
                } else {
                    console.error('Service impact element not found!');
                }
                return;
            }

            // Producer
            const prodMeta = !quorumMaintained
                ? `${red} <span class="font-medium">Control plane:</span> Lost — metadata ops blocked (topic/ACL/partition)`
                : `${green} <span class="font-medium">Control plane:</span> OK — metadata ops available`;

            // Check available brokers and partition health
            const availableBrokers = Object.values(clusterState.brokers).filter(b => b.status === 'UP').length;
            const durabilityReduced = availableBrokers < RF_VALUE;
            const criticalBrokerShortage = availableBrokers < MIN_ISR;
            
            let prodData;
            if (criticalBrokerShortage) {
                // Critical: If available brokers < Min.ISR, NO partition can maintain Min.ISR
                prodData = `${red} <span class=\"font-medium\">Data plane:</span> <strong>ALL WRITES BLOCKED</strong> - Available brokers (${availableBrokers}) < Min.ISR (${MIN_ISR})`;
            } else if (partitionsOffline > 0) {
                // Some partitions have ISR < Min.ISR
                prodData = `${red} <span class=\"font-medium\">Data plane:</span> Writes blocked on ${partitionsOffline} partition(s) (ISR < Min.ISR)`;
            } else if (durabilityReduced) {
                // Available brokers < RF but >= Min.ISR: writes still work but durability reduced
                prodData = `${yellow} <span class=\"font-medium\">Data plane:</span> Writes OK but RF reduced (${availableBrokers}/${RF_VALUE} brokers) - some replicas out-of-sync`;
            } else {
                prodData = `${green} <span class=\"font-medium\">Data plane:</span> Writes OK on all partitions with full replication`;
            }
            const prodRisk = !quorumMaintained
                ? `${yellow} <span class="font-medium">Risk:</span> If a leader fails while quorum is lost, writes stop until quorum restored`
                : '';
            producerMsg = `<div class="space-y-1">${prodMeta}<br>${prodData}${prodRisk ? `<br>${prodRisk}` : ''}</div>`;

            // Consumer
            const consMeta = !quorumMaintained
                ? `${red} <span class="font-medium">Control plane:</span> Lost — metadata refresh/admin blocked`
                : `${green} <span class="font-medium">Control plane:</span> OK — metadata refresh available`;
            let consData;
            if (partitionsOffline > 0) {
                consData = `${red} <span class=\"font-medium\">Data plane:</span> Reads stopped on ${partitionsOffline} partition(s) (ISR < Min.ISR)`;
            } else {
                consData = `${green} <span class=\"font-medium\">Data plane:</span> Reads OK from partitions with current leaders`;
            }
            const consRisk = !quorumMaintained
                ? `${yellow} <span class="font-medium">Risk:</span> If any leader fails, reads stop until quorum restored`
                : '';
            consumerMsg = `<div class="space-y-1">${consMeta}<br>${consData}${consRisk ? `<br>${consRisk}` : ''}</div>`;

            // Connect / Schema Registry
                const dc1ConnectDown = clusterState.services.DC1_CONNECT.status === 'DOWN';
                const dc2ConnectDown = clusterState.services.DC2_CONNECT.status === 'DOWN';
                const dc1SRDown = clusterState.services.DC1_SR.status === 'DOWN';
                const dc2SRDown = clusterState.services.DC2_SR.status === 'DOWN';

            const metaConnect = !quorumMaintained
                ? `${red} <span class="font-medium">Metadata:</span> Registering new tasks/schemas blocked`
                : `${green} <span class="font-medium">Metadata:</span> Registry/Connect admin available`;

            // availability of existing tasks (approximate)
            const dataConnect = `${green} <span class="font-medium">Data I/O:</span> Existing tasks continue if internal topics leaders remain up and ISR ≥ Min.ISR`;
            const svcRisk = !quorumMaintained
                ? `${yellow} <span class="font-medium">Advisory:</span> Freeze config/rollouts until quorum is restored`
                : '';

            const svcDowns = [];
            if (dc1ConnectDown && dc2ConnectDown) svcDowns.push('Connect (both sites)');
            else if (dc1ConnectDown) svcDowns.push('Connect DC1');
            else if (dc2ConnectDown) svcDowns.push('Connect DC2');
            if (dc1SRDown && dc2SRDown) svcDowns.push('Schema Registry (both sites)');
            else if (dc1SRDown) svcDowns.push('Schema Registry DC1');
            else if (dc2SRDown) svcDowns.push('Schema Registry DC2');
            const svcDownNote = svcDowns.length > 0 ? `<br>${red} <span class=\"font-medium\">Outage:</span> ${svcDowns.join(', ')} down` : '';
            serviceMsg = `<div class="space-y-1">${metaConnect}<br>${dataConnect}${svcDownNote}${svcRisk ? `<br>${svcRisk}` : ''}</div>`;

            const producerElement = document.getElementById('producer_impact');
            const consumerElement = document.getElementById('consumer_impact');
            const serviceElement = document.getElementById('service_impact');
            
            console.log('Setting client impact elements:', {
                producer: producerElement,
                consumer: consumerElement,
                service: serviceElement
            });
            
            if (producerElement) {
                producerElement.innerHTML = `<span class="font-bold">Producer (Write)</span><br>${producerMsg}`;
            }
            if (consumerElement) {
                consumerElement.innerHTML = `<span class="font-bold">Consumer (Read)</span><br>${consumerMsg}`;
            }
            if (serviceElement) {
                serviceElement.innerHTML = `<span class="font-bold">Connect/SR</span><br>${serviceMsg}`;
            }
        }


        function renderSequenceLog(log) {
            const container = document.getElementById('sequence_log');
            container.innerHTML = log.map(item => {
                let colorClass = 'text-gray-800';
                if (item.startsWith('--- 🛑')) colorClass = 'font-bold text-base text-red-700 mt-2'; // Summary Header
                else if (item.startsWith('--- KRaft')) colorClass = 'font-bold text-base text-indigo-700 mt-2'; // Sequence Header
                else if (item.startsWith('--- CRITICAL')) colorClass = 'font-bold text-base text-red-700 mt-2'; // CRITICAL Header
                else if (item.startsWith('- ⚠️')) colorClass = 'text-yellow-600 italic ml-4'; // Forced Failure Item
                else if (item.startsWith('-')) colorClass = 'text-red-500 italic ml-4'; // Summary Item
                else if (item.includes('failed') || item.includes('Fails')) colorClass = 'text-red-600';
                else if (item.includes('KRaft Sequence:')) colorClass = 'text-blue-600 italic';
                else if (item.startsWith('✅') || item.includes('MAINTAINED')) colorClass = 'text-green-700 font-medium';
                else if (item.includes('Metadata Refresh')) colorClass = 'text-yellow-700 font-bold';
                else if (item.startsWith('🛑') || item.includes('LOST') || item.includes('Offline')) colorClass = 'text-red-800 font-bold';
                else if (item.startsWith('⚠️') || item.includes('Brief Stutter') || item.includes('Brief Delay')) colorClass = 'text-yellow-700 font-medium';
                else if (item.includes('Leader Changed') || item.includes('New Leader') || item.includes('Election')) colorClass = 'text-orange-700 font-bold animate-pulse';
                else if (item.includes('Force Election') || item.includes('Controller')) colorClass = 'text-indigo-700 font-bold';
                
                // Use a simple <li> for the main sequence items, remove bullet for summary items
                return `<li class="${colorClass}">${item.replace('-', '')}</li>`;
            }).join('');
            
            // Scroll to the bottom of the log container after update
            const logContainer = document.getElementById('sequence_log_container');
            logContainer.scrollTop = logContainer.scrollHeight;
        }


        // Initialize UI on load
        window.onload = () => {
            buildCustomUI();
            
            // Initialize dynamic configuration
            updateConfigImpact();
            recalculatePartitionAssignments();
            
            // Force render client impact immediately
            setTimeout(() => {
                renderClientImpact();
                
                // Force render again after a delay to ensure it works
                setTimeout(() => {
                    renderClientImpact();
                }, 500);
            }, 100);
            
            // Initialize with proper scenario - wait for DOM to be fully ready
            setTimeout(() => {
                // Ensure all components are UP first
                Object.keys(clusterState.brokers).forEach(id => {
                    clusterState.brokers[id].status = 'UP';
                });
                Object.keys(clusterState.kraft_controllers).forEach(id => {
                    clusterState.kraft_controllers[id].status = 'UP';
                });
                Object.keys(clusterState.services).forEach(id => {
                    clusterState.services[id].status = 'UP';
                });
                
                // Update UI to show UP state
                document.querySelectorAll('.status-box-toggle').forEach(element => {
                    element.classList.add('up-state');
                    element.classList.remove('down-state');
                    element.querySelector('.status-text').textContent = 'UP';
                });
                
                // Now call runScenario(5)
                runScenario(5);
                
                // Force render client impact after a delay to ensure DOM is ready
                setTimeout(() => {
                    // Check if elements exist before rendering
                    const producerEl = document.getElementById('producer_impact');
                    const consumerEl = document.getElementById('consumer_impact');
                    const serviceEl = document.getElementById('service_impact');
                    
                    if (producerEl && consumerEl && serviceEl) {
                        renderClientImpact();
                        forceRenderClientImpact();
                    } else {
                        // Try again after a longer delay
                        setTimeout(() => {
                            renderClientImpact();
                            forceRenderClientImpact();
                        }, 1000);
                    }
                }, 500);
            }, 200);
        };

        /**
         * Force render partition status and sequence log
         */
        function forceRenderResults() {
            
            // First, read the current state from UI controls
            const currentState = readCustomState();
            clusterState = JSON.parse(JSON.stringify(currentState));
            clusterState.partitions = JSON.parse(JSON.stringify(initialState.partitions));
            
            // Execute failover logic to get proper results
            const summary = getFailedComponentsSummary();
            const failoverSteps = updateStateAfterFailover(summary);
            
            // Render partition status
            const partitionContainer = document.getElementById('partition_status');
            if (partitionContainer) {
                partitionContainer.innerHTML = '';
                
                Object.keys(clusterState.partitions).forEach((pId, index) => {
                    const partition = clusterState.partitions[pId];
                    const leader = partition.leader;
                    const followers = partition.followers;
                    const allReplicas = [leader, ...followers];
                    
                    // Calculate actual ISR count based on current broker status
                    let isrCount = 0;
                    allReplicas.forEach(brokerId => {
                        if (clusterState.brokers[brokerId] && clusterState.brokers[brokerId].status === 'UP') {
                            isrCount++;
                        }
                    });
                    
                    // Check quorum status
                    const { quorumMaintained } = checkQuorum();
                    const bothIngressDown = 
                        clusterState.services.DC1_INGRESS.status === 'DOWN' &&
                        clusterState.services.DC2_INGRESS.status === 'DOWN';
                    
                    // Determine partition status
                    let statusColor = 'bg-green-100';
                    let statusText = 'text-green-800';
                    let statusDesc = `Leader: ${leader} (${clusterState.brokers[leader].site}). ISR Count: ${isrCount} (Min.ISR: ${MIN_ISR})`;
                    
                    if (bothIngressDown) {
                        statusColor = 'bg-red-100';
                        statusText = 'text-red-800';
                        statusDesc = `Quorum Lost - VIPs DOWN. Partition is **UNAVAILABLE** for clients.`;
                    } else if (!quorumMaintained) {
                        statusColor = 'bg-yellow-100';
                        statusText = 'text-yellow-800';
                        statusDesc = `Quorum Lost (${upControllers}/${QUORUM_REQUIRED}). Control plane unavailable - no new leader elections. Data plane still operational.`;
                    } else if (isrCount < MIN_ISR) {
                        statusColor = 'bg-red-100';
                        statusText = 'text-red-800';
                        statusDesc = `Leader Failed: ${leader}. ISR Count (${isrCount}) < Min.ISR (${MIN_ISR}). **OFFLINE**`;
                    } else if (clusterState.brokers[leader].status === 'DOWN') {
                        statusColor = 'bg-yellow-100';
                        statusText = 'text-yellow-800';
                        statusDesc = `Leader Changed! New Leader: ${leader} (${clusterState.brokers[leader].site}). ISR Count: ${isrCount}`;
                    } else if (currentLeader !== initialLeader) {
                        // Check if leader has changed from initial state
                        statusColor = 'bg-yellow-100';
                        statusText = 'text-yellow-800';
                        statusDesc = `Leader Changed! New Leader: ${leader} (${clusterState.brokers[leader].site}). ISR Count: ${isrCount}`;
                    }
                    
                    const card = `
                        <div class="p-3 rounded-xl shadow-md border ${statusColor} border-gray-200 min-h-[100px]">
                            <h4 class="font-extrabold text-sm mb-1 text-gray-800">${pId}</h4>
                            <p class="text-xs font-semibold ${statusText}">${statusDesc}</p>
                            <p class="text-[10px] text-gray-600 mt-1">Replicas (RF=${RF_VALUE}${AOP_VALUE > 0 ? ` + AOP=${AOP_VALUE}` : ''}): ${allReplicas.join(', ')}</p>
                        </div>
                    `;
                    partitionContainer.innerHTML += card;
                });
            }
            
            // Render sequence log with actual failover steps
            const logContainer = document.getElementById('sequence_log');
            if (logContainer) {
                logContainer.innerHTML = failoverSteps.map(item => {
                    let colorClass = 'text-gray-800';
                    if (item.startsWith('--- 🛑')) colorClass = 'font-bold text-base text-red-700 mt-2';
                    else if (item.startsWith('--- KRaft')) colorClass = 'font-bold text-base text-indigo-700 mt-2';
                    else if (item.startsWith('--- CRITICAL')) colorClass = 'font-bold text-base text-red-700 mt-2';
                    else if (item.startsWith('- ⚠️')) colorClass = 'text-yellow-600 italic ml-4';
                    else if (item.startsWith('-')) colorClass = 'text-red-500 italic ml-4';
                    else if (item.includes('failed') || item.includes('Fails')) colorClass = 'text-red-600';
                    else if (item.includes('KRaft Sequence:')) colorClass = 'text-blue-600 italic';
                    else if (item.startsWith('✅') || item.includes('MAINTAINED')) colorClass = 'text-green-700 font-medium';
                    else if (item.includes('Metadata Refresh')) colorClass = 'text-yellow-700 font-bold';
                    else if (item.startsWith('🛑') || item.includes('LOST') || item.includes('Offline')) colorClass = 'text-red-800 font-bold';
                    else if (item.startsWith('⚠️') || item.includes('Brief Stutter') || item.includes('Brief Delay')) colorClass = 'text-yellow-700 font-medium';
                    
                    return `<li class="${colorClass}">${item.replace('-', '')}</li>`;
                }).join('');
            }
            
            // Also render cluster health and client impact
            renderClusterHealth();
            
            // Force render client impact with error checking
            setTimeout(() => {
                const producerEl = document.getElementById('producer_impact');
                const consumerEl = document.getElementById('consumer_impact');
                const serviceEl = document.getElementById('service_impact');
                
                if (producerEl && consumerEl && serviceEl) {
                    renderClientImpact();
                    forceRenderClientImpact();
                    
                    // Force render again to ensure VIP logic works
                    setTimeout(() => {
                        renderClientImpact();
                    }, 200);
                }
            }, 100);
            
            // Force render client impact if it's empty
            setTimeout(() => {
                const producerImpact = document.getElementById('producer_impact');
                const consumerImpact = document.getElementById('consumer_impact');
                const serviceImpact = document.getElementById('service_impact');
                
                if (!producerImpact.innerHTML || !consumerImpact.innerHTML || !serviceImpact.innerHTML) {
                    console.log('Client impact is empty, forcing render...');
                    forceRenderClientImpact();
                }
            }, 100);
        }

        /**
         * Force render client impact directly
         */
        function forceRenderClientImpact() {
            
            const { quorumMaintained } = checkQuorum();
            const minISR = MIN_ISR;
            let partitionsOffline = 0;
            let ingressDownCount = 0;
            
            // Get DOM elements
            const producerEl = document.getElementById('producer_impact');
            const consumerEl = document.getElementById('consumer_impact');
            const serviceEl = document.getElementById('service_impact');

            // Analyze partition availability
            for (const [pId, pData] of Object.entries(clusterState.partitions)) {
                const isrCount = getISRCount(pId);
                const isAvailable = isrCount >= minISR;
                
                if (!isAvailable) {
                    partitionsOffline++;
                }
            }
            
            if (clusterState.services.DC1_INGRESS.status === 'DOWN') ingressDownCount++;
            if (clusterState.services.DC2_INGRESS.status === 'DOWN') ingressDownCount++;

            // Build compact badges
            const red = '<span class="inline-block w-2.5 h-2.5 rounded-sm bg-red-500 mr-2 align-middle"></span>';
            const yellow = '<span class="inline-block w-2.5 h-2.5 rounded-sm bg-yellow-400 mr-2 align-middle"></span>';
            const green = '<span class="inline-block w-2.5 h-2.5 rounded-sm bg-emerald-500 mr-2 align-middle"></span>';

            const bothIngressDown =
                clusterState.services.DC1_INGRESS.status === 'DOWN' &&
                clusterState.services.DC2_INGRESS.status === 'DOWN';

            // Check total available brokers considering VIP status
            const totalAvailableBrokers = getTotalAvailableBrokers();
            
            // If no brokers are available, all operations are blocked
            if (totalAvailableBrokers === 0) {
                const extMsg = `${red} <span class=\"font-medium\">Cluster:</span> No available brokers — All operations blocked`;
                const producerMsg = `<div class=\"space-y-1\">${extMsg}<br>${red} <span class=\"font-medium\">Data plane:</span> Writes unavailable (no brokers accessible)</div>`;
                const consumerMsg = `<div class=\"space-y-1\">${extMsg}<br>${red} <span class=\"font-medium\">Data plane:</span> Reads unavailable (no brokers accessible)</div>`;
                const serviceMsg = `<div class=\"space-y-1\">${extMsg}<br>${red} <span class=\"font-medium\">Data plane:</span> Connect tasks unavailable (no brokers accessible)</div>`;
            } else if (!quorumMaintained) {
                const controlMsg = `${yellow} <span class=\"font-medium\">Control Plane:</span> ❌ UNAVAILABLE (Metadata operations, Topic creation, ACL changes blocked)`;
                
                // Check if any partitions are offline (ISR count < Min.ISR)
                let hasOfflinePartitions = false;
                for (const [pId, pData] of Object.entries(initialState.partitions)) {
                    const isrCount = getISRCount(pId);
                    if (isrCount < MIN_ISR) {
                        hasOfflinePartitions = true;
                        break;
                    }
                }
                
                let dataMsg, producerMsg, consumerMsg, serviceMsg;
                if (hasOfflinePartitions) {
                    dataMsg = `${red} <span class=\"font-medium\">Data Plane:</span> ❌ UNAVAILABLE (ISR count < Min.ISR - Write operations blocked)`;
                    producerMsg = `<div class=\"space-y-1\">${controlMsg}<br>${dataMsg}<br>${red} <span class=\"font-medium\">Impact:</span> Cannot create new topics, write operations unavailable</div>`;
                    consumerMsg = `<div class=\"space-y-1\">${controlMsg}<br>${dataMsg}<br>${yellow} <span class=\"font-medium\">Impact:</span> Cannot create new topics, read operations may work from remaining replicas</div>`;
                    serviceMsg = `<div class=\"space-y-1\">${controlMsg}<br>${dataMsg}<br>${red} <span class=\"font-medium\">Impact:</span> Connect tasks unavailable, no new tasks can be created</div>`;
                } else {
                    dataMsg = `${yellow} <span class=\"font-medium\">Data Plane:</span> ⚠️ DEGRADED (Read/Write operations limited due to leader failure)`;
                    producerMsg = `<div class=\"space-y-1\">${controlMsg}<br>${dataMsg}<br>${yellow} <span class=\"font-medium\">Impact:</span> Cannot create new topics, limited write capability on existing topics</div>`;
                    consumerMsg = `<div class=\"space-y-1\">${controlMsg}<br>${dataMsg}<br>${yellow} <span class=\"font-medium\">Impact:</span> Cannot create new topics, limited read capability on existing topics</div>`;
                    serviceMsg = `<div class=\"space-y-1\">${controlMsg}<br>${dataMsg}<br>${yellow} <span class=\"font-medium\">Impact:</span> Existing Connect tasks may be affected, no new tasks can be created</div>`;
                }

                document.getElementById('producer_impact').innerHTML = `<span class=\"font-bold\">Producer (Write)</span><br>${producerMsg}`;
                document.getElementById('consumer_impact').innerHTML = `<span class=\"font-bold\">Consumer (Read)</span><br>${consumerMsg}`;
                document.getElementById('service_impact').innerHTML = `<span class=\"font-bold\">Connect/SR</span><br>${serviceMsg}`;
                return;
            }

            // Producer
            const prodMeta = !quorumMaintained
                ? `${red} <span class="font-medium">Control plane:</span> Lost — metadata ops blocked (topic/ACL/partition)`
                : `${green} <span class="font-medium">Control plane:</span> OK — metadata ops available`;

            // Check available brokers and partition health
            const availableBrokers = Object.values(clusterState.brokers).filter(b => b.status === 'UP').length;
            const durabilityReduced = availableBrokers < RF_VALUE;
            const criticalBrokerShortage = availableBrokers < MIN_ISR;
            
            let prodData;
            if (criticalBrokerShortage) {
                // Critical: If available brokers < Min.ISR, NO partition can maintain Min.ISR
                prodData = `${red} <span class=\"font-medium\">Data plane:</span> <strong>ALL WRITES BLOCKED</strong> - Available brokers (${availableBrokers}) < Min.ISR (${MIN_ISR})`;
            } else if (partitionsOffline > 0) {
                // Some partitions have ISR < Min.ISR
                prodData = `${red} <span class=\"font-medium\">Data plane:</span> Writes blocked on ${partitionsOffline} partition(s) (ISR < Min.ISR)`;
            } else if (durabilityReduced) {
                // Available brokers < RF but >= Min.ISR: writes still work but durability reduced
                prodData = `${yellow} <span class=\"font-medium\">Data plane:</span> Writes OK but RF reduced (${availableBrokers}/${RF_VALUE} brokers) - some replicas out-of-sync`;
            } else {
                prodData = `${green} <span class=\"font-medium\">Data plane:</span> Writes OK on all partitions with full replication`;
            }
            const prodRisk = !quorumMaintained
                ? `${yellow} <span class="font-medium">Risk:</span> If a leader fails while quorum is lost, writes stop until quorum restored`
                : '';
            const producerMsg = `<div class="space-y-1">${prodMeta}<br>${prodData}${prodRisk ? `<br>${prodRisk}` : ''}</div>`;

            // Consumer
            const consMeta = !quorumMaintained
                ? `${red} <span class="font-medium">Control plane:</span> Lost — metadata refresh/admin blocked`
                : `${green} <span class="font-medium">Control plane:</span> OK — metadata refresh available`;
            let consData;
            if (partitionsOffline > 0) {
                consData = `${red} <span class=\"font-medium\">Data plane:</span> Reads stopped on ${partitionsOffline} partition(s) (ISR < Min.ISR)`;
            } else {
                consData = `${green} <span class=\"font-medium\">Data plane:</span> Reads OK from partitions with current leaders`;
            }
            const consRisk = !quorumMaintained
                ? `${yellow} <span class="font-medium">Risk:</span> If any leader fails, reads stop until quorum restored`
                : '';
            const consumerMsg = `<div class="space-y-1">${consMeta}<br>${consData}${consRisk ? `<br>${consRisk}` : ''}</div>`;

            // Connect / Schema Registry
            const dc1ConnectDown = clusterState.services.DC1_CONNECT.status === 'DOWN';
            const dc2ConnectDown = clusterState.services.DC2_CONNECT.status === 'DOWN';
            const dc1SRDown = clusterState.services.DC1_SR.status === 'DOWN';
            const dc2SRDown = clusterState.services.DC2_SR.status === 'DOWN';

            const metaConnect = !quorumMaintained
                ? `${red} <span class="font-medium">Metadata:</span> Registering new tasks/schemas blocked`
                : `${green} <span class="font-medium">Metadata:</span> Registry/Connect admin available`;

            // availability of existing tasks (approximate)
            const dataConnect = `${green} <span class="font-medium">Data I/O:</span> Existing tasks continue if internal topics leaders remain up and ISR ≥ Min.ISR`;
            const svcRisk = !quorumMaintained
                ? `${yellow} <span class="font-medium">Advisory:</span> Freeze config/rollouts until quorum is restored`
                : '';

            const svcDowns = [];
            if (dc1ConnectDown && dc2ConnectDown) svcDowns.push('Connect (both sites)');
            else if (dc1ConnectDown) svcDowns.push('Connect DC1');
            else if (dc2ConnectDown) svcDowns.push('Connect DC2');
            if (dc1SRDown && dc2SRDown) svcDowns.push('Schema Registry (both sites)');
            else if (dc1SRDown) svcDowns.push('Schema Registry DC1');
            else if (dc2SRDown) svcDowns.push('Schema Registry DC2');
            const svcDownNote = svcDowns.length > 0 ? `<br>${red} <span class=\"font-medium\">Outage:</span> ${svcDowns.join(', ')} down` : '';
            const serviceMsg = `<div class="space-y-1">${metaConnect}<br>${dataConnect}${svcDownNote}${svcRisk ? `<br>${svcRisk}` : ''}</div>`;

            if (producerEl) {
                producerEl.innerHTML = `<span class="font-bold">Producer (Write)</span><br>${producerMsg}`;
                console.log('Producer impact set:', producerMsg);
            } else {
                console.error('Producer impact element not found!');
            }
            
            if (consumerEl) {
                consumerEl.innerHTML = `<span class="font-bold">Consumer (Read)</span><br>${consumerMsg}`;
                console.log('Consumer impact set:', consumerMsg);
            } else {
                console.error('Consumer impact element not found!');
            }
            
            if (serviceEl) {
                serviceEl.innerHTML = `<span class="font-bold">Connect/SR</span><br>${serviceMsg}`;
                console.log('Service impact set:', serviceMsg);
            } else {
                console.error('Service impact element not found!');
            }
        }
    </script>
</body>
</html>
